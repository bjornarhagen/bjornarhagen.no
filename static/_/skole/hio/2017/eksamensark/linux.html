<!DOCTYPE html>
<html lang="no">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="initial-scale=1, maximum-scale=2.5, width=device-width, height=device-height">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Linux - eksamensark</title>
	<link rel="stylesheet" href="css/exam-paper.css">
	<link rel="stylesheet" href="css/exam-paper-linux.css">
	<link rel="stylesheet" href="css/katex.min.css">
	<script src="js/app.js"></script>
</head>
<body>
	<div class="wrapper">
		<section class="w4">
			<div class="row">
				<h1><strong class="fsl">2</strong> Kommandoer</h1>
				<table>
					<thead>
						<tr>
							<th>Hvordan...</th>
							<th>Kommando</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><b>Elementær navigering</b></td>
						</tr>
						<tr>
							<td>får jeg mer info om en kommando?</td>
							<td>man &lt;kommando&gt;<br>&lt;kommando&gt; --help</td>
						</tr>
						<tr>
							<td>lister jeg filer i en katalog?</td>
							<td>ls</td>
						</tr>
						<tr>
							<td>skifter jeg katalog?</td>
							<td>cd &lt;katalog&gt; </td>
						</tr>
						<tr>
							<td>vet jeg i hvilken katalog jeg er?</td>
							<td>pwd</td>
						</tr>
						<tr>
							<td>oppretter/fjerner jeg en katalog?</td>
							<td>mkdir/rmdir &lt;katalog&gt; </td>
						</tr>
						<tr>
							<td>kopierer jeg en fil?</td>
							<td>cp </td>
						</tr>
						<tr>
							<td>sletter jeg en fil?</td>
							<td>rm</td>
						</tr>
						<tr>
							<td>lager jeg en (tom) fil?</td>
							<td>touch</td>
						</tr>
						<tr>
							<td>flytter jeg en fil/endrer navn på fil</td>
							<td>mv</td>
						</tr>
						<tr>
							<td>lister jeg innholdet i en fil?</td>
							<td>cat / more / less</td>
						</tr>
						<tr>
							<td>får jeg opp informasjon om diskbruk?</td>
							<td>df</td>
						</tr>
						<tr>
							<td>sjekker jeg hvor mye diskplass brukt?</td>
							<td>du -sh</td>
						</tr>
						<tr>
							<td>sjekker jeg ledig minne?</td>
							<td>free</td>
						</tr>
						<tr>
							<td>finner jeg en spesifikk fil?</td>
							<td>find / whereis &lt;fil&gt;</td>
						</tr>
						<tr>
							<td>lager jeg en snarvei?</td>
							<td>ln -s &lt;faktisk_fil&gt; &lt;snarvei&gt;</td>
						</tr>
						<tr>
							<td>pakker jeg inn/ut filer?</td>
							<td>gzip/bunzip / tar</td>
						</tr>
						<tr>
							<td><b>Bruker-relaterte kommandoer</b></td>
						</tr>
						<tr>
							<td>vet jeg hvem jeg er?</td>
							<td>whoami</td>
						</tr>
						<tr>
							<td>logger jeg meg inn som root?</td>
							<td>su</td>
						</tr>
						<tr>
							<td>endrer jeg passord?</td>
							<td>passwd</td>
						</tr>
						<tr>
							<td>får jeg opp diverse info om systemet?</td>
							<td>w</td>
						</tr>
						<tr>
							<td>finner jeg ut mer om en bruker?</td>
							<td>finger</td>
						</tr>
						<tr>
							<td>endrer jeg rettigheter på filer?</td>
							<td>chmod</td>
						</tr>
						<tr>
							<td>endrer jeg eierskap på filer?</td>
							<td>chown</td>
						</tr>
						<tr>
							<td>legger jeg til bruker?</td>
							<td>useradd</td>
						</tr>
						<tr>
							<td>endrer jeg mitt shell?</td>
							<td>chsh</td>
						</tr>
						<tr>
							<td><b>Enkle nettverkskommandoer</b></td>
						</tr>
						<tr>
							<td>sjekker jeg om en boks er på nett?</td>
							<td>ping</td>
						</tr>
						<tr>
							<td>konfigurerer jeg nettverket?</td>
							<td>ifconfig</td>
						</tr>
						<tr>
							<td>bruker jeg traceroute?</td>
							<td>traceroute</td>
						</tr>
						<tr>
							<td>snakker jeg med andre som er innlogget?</td>
							<td>talk</td>
						</tr>
						<tr>
							<td><b>Mer avanserte kommandoer</b></td>
						</tr>
						<tr>
							<td>finner jeg ut hvilken linux-ver jeg har?</td>
							<td>uname<br>
								cat /proc/version</td>
						</tr>
						<tr>
							<td>får jeg tilgang til andre disker?</td>
							<td>mount</td>
						</tr>
						<tr>
							<td>formaterer jeg en disk?</td>
							<td>mkfs</td>
						</tr>
						<tr>
							<td>sjekker jeg om en disk er skadet?</td>
							<td>fsck</td>
						</tr>
						<tr>
							<td>lister jeg alle prosesser?</td>
							<td>ps</td>
						</tr>
						<tr>
							<td>lister jeg alle prosesser i en fin tabell?</td>
							<td>top</td>
						</tr>
						<tr>
							<td>avslutter (dreper) jeg en prosess?</td>
							<td>kill</td>
						</tr>
						<tr>
							<td>slår jeg av boksen?</td>
							<td>shutdown</td>
						</tr>
						<tr>
							<td>partitionerer jeg en disk?</td>
							<td>fdisk</td>
						</tr>
						<tr>
							<td>viser jeg all oppstarts-info?</td>
							<td>dmesg</td>
						</tr>
						<tr>
							<td>aktiverer jeg shadow passord?</td>
							<td>pwconv</td>
						</tr>
						<tr>
							<td>lister hvilke moduler som er lastet?</td>
							<td>lsmod</td>
						</tr>
						<tr>
							<td><b>Annet</b></td>
						</tr>
						<tr>
							<td>sjekker jeg hvilket skjermkort jeg har?</td>
							<td>SuperProbe</td>
						</tr>
						<tr>
							<td>konfigurerer jeg X?</td>
							<td>xf86config</td>
						</tbody>
						</tr>
				</table>
			</div>
		</section>
		<section class="w6">
			<div class="row">
				<h1>Forklaring</h1>
				<dl>
					<dt><h2>ls</h2></dt>
					<dd>Brukes for å bytte <em>working directory</em></dd>
					<dd><code>ls [options] [file|dir]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>ls -a</td>
									<td>list all files including hidden file starting with '.'</td>
								</tr>
								<tr>
									<td>ls --color</td>
									<td>colored list [=always/never/auto]</td>
								</tr>
								<tr>
									<td>ls -d</td>
									<td>list directories - with ' */'</td>
								</tr>
								<tr>
									<td>ls -F</td>
									<td>add one char of */=&gt;@| to enteries</td>
								</tr>
								<tr>
									<td>ls -i</td>
									<td>list file's inode index number</td>
								</tr>
								<tr>
									<td>ls -l</td>
									<td>list with long format - show permissions</td>
								</tr>
								<tr>
									<td>ls -la</td>
									<td>list long format including hidden files</td>
								</tr>
								<tr>
									<td>ls -lh</td>
									<td>list long format with readable file size</td>
								</tr>
								<tr>
									<td>ls -ls</td>
									<td>list with long format with file size</td>
								</tr>
								<tr>
									<td>ls -r</td>
									<td>list in reverse order</td>
								</tr>
								<tr>
									<td>ls -R</td>
									<td>list recursively directory tree</td>
								</tr>
								<tr>
									<td>ls -s</td>
									<td>list file size</td>
								</tr>
								<tr>
									<td>ls -S</td>
									<td>sort by file size</td>
								</tr>
								<tr>
									<td>ls -t</td>
									<td>sort by time & date</td>
								</tr>
								<tr>
									<td>ls -X</td>
									<td>sort by extension name</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>ls ~cathrineb</td>
									<td>Skriver ut innholdet i hjemmekatalogen til brukeren cathrineb (hvis du har lesetilgang til denne katalogen).</td>
								</tr>
								<tr>
									<td>ls -ld h*</td>
									<td>Skriver ut, i langt format (opsjonen '-l), informasjon om alle katalogfiler/underkataloger
									(opsjonen '-d) i stående katalog med navn som begynner på 'h'. Innholdet i katalogene skrives ikke ut.</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>cd</h2></dt>
					<dd>Brukes for å bytte <em>working directory</em></dd>
					<dd><code>cd [option] [directory]</code></dd>

					<dt>pwd</dt>
					<dd>Viser i hvilken katalog som bruker befinner seg i.</dd>
					<dd>
						<dl>
							<dt>Eksempel</dt>
							<dd>
<pre class="fss">
[bruker@pc /]$ cd ~
[bruker@pc ~]$ pwd
/home/bruker
</pre>
							</dd>
						</dl>
					</dd>

					<dt>mkdir/rmdir</dt>
					<dd>Disse kommandoene oppretter/fjerner kataloger. NB! Katalogen må være tom før du får slettet den med denne kommandoen.</dd>

					<dt><h2>cp</h2></dt>
					<dd>Brukes for å kopiere filer og/eller kataloger</dd>
					<dd><code>cp [options] source dest</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>cp -r</td>
									<td>Copy recursively</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>mv</h2></dt>
					<dd>Brukes for å flytte filer og/eller kataloger</dd>
					<dd>Kan også brukes for å endre navn på filer eller kataloger</dd>
					<dd><code>mv [options] source dest</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>mv -f</td>
									<td>force move by overwriting destination file without prompt</td>
								</tr>
								<tr>
									<td>mv -i</td>
									<td>interactive prompt before overwrite</td>
								</tr>
								<tr>
									<td>mv -u</td>
									<td>update - move when source is newer than destination</td>
								</tr>
								<tr>
									<td>mv -v</td>
									<td>verbose - print source and destination files</td>
								</tr>
							</tbody>
						</table>
					</dd>
					<dd>
						<strong>Eksempler</strong>
						<dl>
							<dt><code>[bruker@pc ~]$ mv testfil katalog1/</code></dt>
							<dd>Vi flytter filen testfil1 til katalog1/</dd>

							<dt><code>[bruker@pc ~]$  mv testfil nyttnavn</code></dt>
							<dd>Vi "flytter" filen til ett annet navn.</dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt><h2><strong class="fsl">3</strong> alias</h2></dt>
					<dd>Brukes for å lage aliaser til kommandoer</dd>
					<dd><code>alias [-p] [name[=value] ... ]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>alias -p [name[=value] ...]</td>
									<td>print all defined aliases in a reusable format</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>alias harakiri 'rm -r'</td>
									<td>Definerer et kommandoalias med navn harakiri, som skal fjerne alle filer i stående katalog og alle
									underkataloger av stående katalog.</td>
								</tr>	
							</tbody>
						</table>
					</dd>

					<dt><h2>rm</h2></dt>
					<dd>Brukes for å slette filer og/eller kataloger</dd>
					<dd><code>rm [OPTION]... FILE...</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>-f, --force</td>
									<td>Ignore nonexistant files, and never prompt before removing.</td>
								</tr>
								<tr>
									<td>-i</td>
									<td>Prompt before every removal.</td>
								</tr>
								<tr>
									<td>-I</td>
									<td>Prompt once before removing more than three files, or when removing recursively. Less intrusive than -i, while still giving protection against most mistakes.</td>
								</tr>
								<tr>
									<td>--interactive[=<em>WHEN</em>]</td>
									<td>Prompt according to <em>WHEN</em>: never, once (-I), or always (-i). If <em>WHEN</em> is not specified, then prompt always.</td>
								</tr>
								<tr>
									<td>--one-file-system</td>
									<td>When removing a hierarchy recursively, skip any directory that is on a file system different from that of the corresponding command line argument</td>
								</tr>
								<tr>
									<td>--no-preserve-root</td>
									<td>Do not treat "/" (the root directory) in any special way.</td>
								</tr>
								<tr>
									<td>--preserve-root</td>
									<td>Do not remove "/" (the root directory), which is the default behavior.</td>
								</tr>
								<tr>
									<td>-r, -R, --recursive</td>
									<td>Remove directories and their contents recursively.</td>
								</tr>
								<tr>
									<td>-v, --verbose</td>
									<td>Verbose mode; explain at all times what is being done.</td>
								</tr>
								<tr>
									<td>--help</td>
									<td>Display a help message, and exit.</td>
								</tr>
								<tr>
									<td>--version</td>
									<td>Display version information, and exit.</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>rm -rf firefox/cache/*</td>
									<td>Fjerner alle filer som brukeren er eier av (uansett filbeskyttelse) i hele katalogtreet med rot i
									underkatalogen ./firefox/cache/ .</td>
								</tr>
								<tr>
									<td>rm -f ~/personal/memo*.doc</td>
									<td>Fjerner alle filer som ligger i katalogen personal med filnavn som starter med memo og slutter med
									.doc</td>
								</tr>
								<tr>
									<td>rm -f ~/linuxbook/final/ch??.prn</td>
									<td>Fjerner alle filer som ligger i katalogen final, som er en underkatalog av linuxbook, med filnavn
									på åtte tegn som starter med ch, etterfulgt av to vilkårlige tegn, og deretter slutter med .prn</td>
								</tr>
								<tr>
									<td>rm -f ~/linuxbook/final/*.o</td>
									<td>Fjerner alle filer som ligger i katalogen final, som er en underkatalog av linuxbook, med filnavn
									som slutter med .o</td>
								</tr>
								<tr>
									<td>rm -f ~/courses/ece446/lab[1-6].[cC]</td>
									<td>Fjerner alle filer som ligger i katalogen ece446, som er en underkatalog av courses, med filnavn
									på 6 tegn som starter med lab, etterfulgt av ett av sifrene 1-6, og deretter slutter med .c eller .C</td>
								</tr>
							</tbody>
						</table>
					</dd>

					<dt><h2>cat</h2></dt>
					<dd>Brukes for å vise innholdet i en fil</dd>
					<dd>Cat kommandoen er meget nyttig. Cat har flere funksjoner, men elementært, så leser den en fil og viser den til "standard output". Kort (og grovt) fortalt, kan vi si at kommadoen henter ett filformat og "kaster" den til riktig utgang. F.eks. kan vi "kaste" en musikk-fil til lydkortet (og dermed få lyd), eller en fil til printerporten (og printe ut noe).</dd>
					<dd><code>cat [options] file1 [file2...]</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>cat -b</td>
									<td>add line numbers to non blank lines</td>
								</tr>
								<tr>
									<td>cat -n</td>
									<td>add line numbers to all lines</td>
								</tr>
								<tr>
									<td>cat -s</td>
									<td>squeeze blank lines to one line</td>
								</tr>
								<tr>
									<td>cat -E</td>
									<td>show $ at the end of line</td>
								</tr>
								<tr>
									<td>cat -T</td>
									<td>show ^I instead of tabs</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
								<tr>
									<td>cat < fil_1 >> fil_2</td>
									<td>fil_1 legges til på slutten av fil_2</td>
								</tr>
								<tr>
									<td class="wrap">cat < kapittel_1.txt | tee kapittel_1.txt.backup | lpr</td>
									<td>En kopi av filen kapittel_1.txt lagres på filen kapittel_1.txt.backup. kapittel_1.txt sendes også
									til utskrift på default printer.</td>
								</tr>
							</tbody>
						</table>
					</dd>

				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>df -h</dt>
					<dd>Viser hvor mye ledig diskplass som er ledig. Ved bruk av df -h gir det en litt mer leslig format (megabyte, kilobyte etc.). Eks:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            3,8G     0  3,8G   0% /dev
tmpfs           783M   11M  773M   2% /run
/dev/nvme0n1p2  234G   56G  167G  25% /
</pre>
					</dd>
					<dt>du -sh</dt>
					<dd>Viser hvor mye plass stående katalogen (med underkataloger) tar av diskplass. Eks:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ pwd
/home/bruker
[bruker@pc ~]$ dh -sh
35.6G    .
[bruker@pc ~]$ cd testmappe
[bruker@pc testmappe]$ pwd
/home/bruker/testmappe
[bruker@pc testmappe]$ dh -sh
2.1M     .
</pre>
					</dd>

					<dt>free</dt>
					<dd>Viser hvor systemets bruk av minne. "free -m" viser minnebruken i megabytes.</dd>

					<dt>find / whereis</dt>
					<dd>Den første kommandoen, find, leter gjennom de kataloger som er eksportert til bash. Den andre kommandoen, whereis, er leter mer omfattende. Se også kommandoen, locate for mer avansert filsøking.</dd>
					<dd><code>[bruker@pc testmappe]$ find . -name '*.java' -exec basename {} \; | sort</code></dd>
					<dd>Kommandoen over skriver ut en sortert liste med navnene på alle filer i hele katalogtreet med rot i stående katalog, som har et filnavn som slutter med .java (se manualsidene for find og basename).</dd>

					<dt>ln</dt>
					<dd>Filer kan ha flere navn i UNIX/Linux. Dette gjøres ved kommandoen ln. Du oppretter da en snarvei til den faktiske filen.</dd>
					<dd><code>[bruker@pc testmappe]$ ln /mappe/undermappe/filen /home/bruker/snarvei</code></dd>
					<dd>Oppretter her en snarvei, kalt "snarvei", som peker på filen "/mappe/undermappe/filen"</dd>

					<dt>gzip / bzip2</dt>
					<dd>For å pakke ned en fil, brukes kommandoen:</dd>
					<dd>
						<dl>
							<dt><code>[bruker@pc ~]$ gzip en_fil</code></dt>
							<dd>"en_fil" vil da bli pakket ned, og den pakkede filen får navn "en_fil.gz". Merk! "en_fil.gz" erstatter "en_fil"! Du får dermed kun en kopi av den pakkede filen!</dd>

							<dt><code>[bruker@pc ~]$ gzip -9 en_fil</code></dt>
							<dd>Ved å bruke -9, vil det si at vi bruker maksimal kompresjon. Ved å bruke lavere tall, vil det ta kortere tid å pakke ned, men den pakkede filen vil bli større.</dd>
						</dl>
						<dd>For å pakke ut en fil brukes følgende kommando:</dd>
						<dl>
							<dt><code>[bruker@pc ~]$ gunzip en_fil.gz</code></dt>
							<dd>bzip2 er en forbedret utgave av gzip. Den bruker en litt annen komprimerings-algoritme, og får pakket ned filer bedre. Den bruke på samme måte som gzip/gunzip, bare at det er bzip2/bunzip2. De pakkede filene vil få navn som "en_fil.bz2". Se man sidene for mer avansert bruk av gzip/bzip2.</dd>
						</dl>
					</dd>

					<dt>tar</dt>
					<dd>Tar ble opprinnlig brukt til backup. Legger alle filer og kataloger i en stor fil, som det igjen ble tatt backup av. Det fine med tar, er at du kan pakke ned hele katalogstrukturer, noe som ikke går med gzip/bzip2. Ofte er tar brukt til først å pakke ned i en stor fil, også pakket med gzip. Dissse filene har ending .tar.gz, også kalt "tarball". Eldre slike filer kan også ha ending .tar.Z. Det er også .tar.gz2 filer, som pakket med tar og pakket ned med gzip. Kernelkildekoden er pakket på denne måten. Pakker ut en tarball med følgende kommando:</dd>
					<dd>
						<dl>
							<dt><code>[bruker@pc ~]$ tar zxfv backupavfil.tar.gz</code></dt>
							<dd>Igjen, for mer (masse) informasjon om bruk, se man sidene.</dd>
						</dl>
					</dd>

					<dt>passwd</dt>
					<dd>Gjør at du skifter passord. Denne kommandoen skifter kun passord på din lokale maskin. Merk! Hvis det er et nettverk, er det mest sannsynlig "yppasswd" ("yp on lan" eller "Yellow Pages on Local Area Network"). Root kan selvfølgelig skifte passord på hvem han selv måtte ønske ("passwd lars").</dd>
					<dd>Root kan også stenge en konto ved å bruke følgende kommando:</dd>
					<dd><code>[bruker@pc ~]$ passwd -l lars</code></dd>
					<dd>Passordet for denne kontoen settes da til noe ugjettbart :) For å låse opp denne kontoen bruker vi kommandoen:</dd>
					<dd><code>[bruker@pc ~]$ passwd -u lars</code></dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt>chmod</dt>
					<dd>Linux/Unix har et innfløkt (men logisk) system for filtildeling. Filtildeinger gis ved kommadoen chmod.</dd>
					<dd>
						<dl>
							<dt>Først litt teori:</dt>
							<dd>Eks: Ved å skrive ls -l kommer følgende opp:</dd>
							<dd>
<pre class="fss">
[bruker@pc ~]$ ls -l
-rw-rw-r-- 1 bjornar bjornar     0 nov.   8 15:13 a.out
lrwxrwxrwx 1 bjornar bjornar    20 okt.  27 01:37 bin -> .dotfiles/common/bin
lrwxrwxrwx 1 bjornar bjornar    22 okt.  27 01:37 crontab -> .dotfiles/cron/crontab
drwxr-xr-x 2 bjornar bjornar  4096 nov.  15 13:54 Desktop
drwxr-xr-x 5 bjornar bjornar  4096 nov.  29 12:09 Documents
drwxr-xr-x 2 bjornar bjornar  4096 des.   4 11:52 Downloads
drwx------ 9 bjornar bjornar  4096 des.   5 10:36 Drive
drwxr-xr-x 2 bjornar bjornar  4096 okt.  27 01:31 Music
drwxr-xr-x 3 bjornar bjornar  4096 nov.   7 13:58 Pictures
drwxr-xr-x 2 bjornar bjornar  4096 okt.  27 01:31 Templates
drwxr-xr-x 3 bjornar bjornar  4096 okt.  27 17:04 Videos
lrwxrwxrwx 1 bjornar bjornar    20 okt.  27 01:37 .vimrc -> .dotfiles/vim/.vimrc
-rw-r--r-- 1 bjornar users     165 okt.  30 11:10 .wget-hsts
</pre>
							</dd>
							<dd>La oss se på den første kolonnen til den siste filen her... (.wget-hsts)</dd>
							<dd class="fsm"><strong><span class="purple">-</span><span class="blue">rw-</span><span class="red">r--</span><span class="green">r--</span></strong> bjornar users 165 okt...</dd>
							<dd>Det første tegnet er <span class="purple">-</span>, sier hva slags fil dette er (<code>d</code> for kataloger,
							<code>c</code> for enheter osv.). Videre er det 3 tegn <span class="blue">rw-</span> (blå) + 3 tegn <span class="red">r--</span>
							(rød) + 3 tegn <span class="green">r--</span> (grønn) = 3 x 3. Tilsammen 10 tegn. La oss forklare hvert segment (hver farge).</dd>
							<dd>
								<dl>
									<dt>Blå</dt>
									<dd>De første tre symbolene er filtildelingene for de som eier filene (i dette tilfelle ser vi at der et bjornar). Dette første segmentet kalles "u" for "user".</dd>

									<dt>Rød</dt>
									<dd>De neste tre symbolene er tilganger for gruppe (i dette tilfellet "users" - Hvis jeg hadde vært i f.eks. gruppen "frisurf", så kunne jeg gitt tilganger til andre som var i min gruppe (dvs. "frisurf"). Andre grupper, f.eks. "total" ville ikke ha hatt de samme tilganger.). Kalt segment "g" for "group".</dd>

									<dt>Grønn</dt>
									<dd>De tre siste symbolene er tilganger for alle andre (dvs. hvemsomhelst). Kalles semgent "o" for "other".</dd>
								</dl>
							</dd>
						</dl>
					</dd>
					<dd>
						<dl>
							<dt>Rettigheter</dt>
							<dd>r = read</dd>
							<dd>w = write</dd>
							<dd>x = execute (NB! For å få tilgang til kataloger, må de ha tilgang til å bli eksekverbare)</dd>

							<dt>Hvordan endre rettigheter?</dt>
							<dd>1, Du angir først hvem endringen skal gjelde for (enten user, group eller other). </dd>
							<dd>2. Deretter + eller - </dd>
							<dd>3. Tilslutt hva slags rettigheter som skal settes (som er read, write eller execute)</dd>

							<dt>Eksempeler</dt>

							<dl>
								<dt><code>[bruker@pc ~]$ chmod o+rw test.txt</code></dt>
								<dd>Denne kommandoen vil gi lese (r) og skrive (w) til alle andre (other) for filen test.txt</dd>

								<dt><code>[bruker@pc ~]$ chmod o-rw test.txt </code></dt>
								<dd>Dette gjør det motsatte, nemlig å fjerne lese og skrive rettigheter for filen test.txt for alle andre (other).</dd>

								<dt><code>[bruker@pc ~]$ chmod go-x lars/</code></dt>
								<dd>Gjør at jeg sperrer katalogen lars/ for både min gruppe (group) og alle andre (other). Som bruker har jeg fremdeles mine tilganger inntakt (user).</dd>

								<dt><code>[bruker@pc ~]$ chmod go= fil1</code></dt>
								<dd>Fjerner alle tilgangsrettigheter til fil1 for alle brukere untatt eier av filen (user).</dd>

								<dt><code>[bruker@pc ~]$ chmod a=rwx fil2</code></dt>
								<dd>Gir alle brukere lese-, skrive- og kjøretilgang til fil2.</dd>

								<dt><code>[bruker@pc ~]$ chmod -R 644 *.html</code></dt>
								<dd>Gir eier lese- og skrivetilgang og alle andre lesetilgang, til alle filer som har et navn som slutter på .html, rekursivt i hele katalogtreet med rot i stående i katalog.</dd>

								<dt><code>[bruker@pc ~]$ chmod 777 fil3</code></dt>
								<dd>Gir alle brukere lese-, skrive- og kjøretilgang til fil3.</dd>

								<dt><code>[bruker@pc ~]$ find . -name \*.html -exec chmod 644 {} \;</code></dt>
								<dd>Gjør nøyaktig det samme som kommandoen i punkt 3 ovenfor.</dd>
							</dl>
						</dl>
					</dd>

				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>chown < bruker:gruppe > < fil/katalog ></dt>
					<dd>Selv om rettighetene er i orden, så forutsetter det at bruker eier filen/katalogen. Merk! Det er kun root som kan skifte eierskap av filer/kataloger. Eks:</dd>
					<dd><code>[bruker@pc ~]$ chown brev.txt liuns</code></dd>
					<dd>Jeg gir bruker "linus" eierskap til filen "brev.txt".</dd>
					<dd><code>chown root:mygroup /usr/local/folder -R</code></dd>
					<dd>Alle filer og undermapper i /usr/local/folder blir nå eid av bruker root og gruppen mygroup</dd>

					<dt>finger < en_bruker ></dt>
					<dd>Er en kommando som kan brukes til å få opp informasjon om en bruker på systemet. Hvis brukeren har en .plan og/eller .project med utfyllende beskrivelse, kan en annen bruker få opp denne informasjonen ved å bruker finger < bruker >. NB! Denne tjenesten kan være utilgjengelig på enkelte systemer, dette fordi system-administratoren har gjort dette av sikkerhetshensyn. Prøv å skriv:</dd>
					<dd><code>[bruker@pc ~]$ finger volkerdi@slackware.com</code></dd>
					<dd>Som gjør at du får opp finger kommandoer om Patrick Volkerding; mannen bak Slackware.</dd>
					<dd>eller</dd>
					<dd><code>[bruker@pc ~]$ finger johnc@idsoftware.com</code></dd>
					<dd>Med denne kommandoen får du opp informasjon om John Carmack - mannen bak alle grafikk-motorene til ID Software. Carmack pleier å ha mye oppdatert informasjon om grafikk-kort og fremtdige prosjekter til ID Software.</dd>
					<dd>eller</dd>
					<dd><code>[bruker@pc ~]$ finger larstra@ifi.uio.no</code></dd>

					<dt>useradd </dt>
					<dd>Kommando for å legge til brukere.</dd>
					<dd><code>[bruker@pc ~]$ useradd ola -p ola42 -d /home/ola -m</code></dd>
					<dd>Legger til ola-bruker med passord "ola42", og med hjemmekatalog under /home/ola. Se man useradd for mer info. Ofte følger det med egne "useradd"-script for hver distribusjon; "adduser" i Slackware, "YaSt" i Suse osv. KDE har også ett eget grafisk bruker administrasjons program.</dd>

					<dt>userdel</dt>
					<dd>Fjerner bruker fra systemet.</dd>
					<dd><code>[bruker@pc ~]$ userdel -r ola</code></dd>
					<dd>Fjerner brukeren ola fra systemet. Sletter samtidig hjemmekatalogen.</dd>

					<dt>chsh</dt>
					<dd>Hvis brukeren har lyst til å endre sitt shell, gjøres det med denne kommandoen. Ulike shell kan dekke ulike behov. Sjekk først hvilke shell som er tilgjenglig i filen "/etc/shells". Les mer om shell under ordliste.</dd>

					<dt>ping</dt>
					<dd>Dette er noe av den enkleste nettverkskommandoen. Det denne kommandoen gjør, er å se om en annen burk på er på nettverket. Denne kommandoen kan også brukes for å se om du har nettverks-trafikk overhode. Prøve f.eks.</dd>
					<dd><code>[bruker@pc ~]$ ping www.online.no</code></dd>

					<dt>ifconfig</dt>
					<dd>Denne kommandoen konfigurerer ett nettverks-"interface". Eks:</dd>
					<dd><code>[bruker@pc ~]$ ifconfig eth0 10.1.1.2 broadcast 10.1.1.255 netmask 255.255.255.0</code></dd>
					<dd>Denne setter opp eth0, som er vårt første nettverkskort (og eneste, hvis vi kun har ett kort i boksen), til å bruke IP-adresse 10.1.1.2. Videre broadcaster den til hele 10.1.1 subnettet. Du kan nesten alltid bruke netmaske 255.255.255.0. Hvis du vil bruke andre instillinger, vet du nok allerede nok om denne slags konfigurasjonen :) Sjekk man sidene for mer informasjon.</dd>
					<dd>Denne kommandoen kan også få opp generell informasjon om interfacet ved kun å skrive "ifconfig".</dd>

					<dt>traceroute</dt>
					<dd>Viser veien nettverks-pakkene må gå for å komme frem til en destinasjonen. Prøv f.eks.</dd>
					<dd><code>[bruker@pc ~]$ traceroute www.uio.no</code></dd>

					<dt>talk</dt>
					<dd>talk < bruker >, åpen er en enkel snakke-kanal med en annne bruker. Den du prøver å snakke med må også skrive talk < bruker > for at forbindelsen skal oppnås.</dd>

				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section class="w6">
			<div class="row">
				<dl>
					<dt>mount</dt>
					<dd>Avgjør hva som kan aksesseres. Alle harddisker blir mountet til filer (kataloger) under Linux. Faktisk så er alle enhetene i maskinen filer under Linux. Les mer om dette her. En harddisk, cd-rom, diskettstasjon, må "mountes" før de kan aksesseres. Det er to måter å mounte filsystemer på: vanskelig og enkel.
					Vanskelig: Når en enhet mountes, må vi vite all relevant informasjon om filsystemet, som vi så plotter inn til en kommando. 
					Kommandoen blir noe slikt: mount < option > enhet < katalog >. La oss belyse med ett eksempel; mounting av en CD-ROM:</dd>
					<dd><code>[bruker@pc ~]$ mount -t iso9660 -o ro /dev/hdc /cdrom</code></dd>
					<dd>Det å måtte tast inn dette hver gang vi skal ha tilgang til cdrom'en blir fort kjedelig, derfor ser vi nærmere på den enkle måten..</dd>
					<dd>Enkel: En enkelt måte å slippe å gjøre dette hver gang vi skal få tilgang til cd-romen er å legge all denne informasjonen inn i /etc/fstab. Som det meste annet i Linux, er også denne filen en ren tekst fil. Slik kan en /etc/fstab fil se ut:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ cat /etc/fstab
/dev/sda1   /            ext2     defaults           1   1
/dev/sda2   /usr/local   ext2     defaults           1   2
/dev/sda3   /home        ext2     defaults           1   2
/dev/sda4   swap         swap     defaults           0   0
none        /dev/pts     devpts   gid=5,mode=620     0   0
none        /proc        proc     defaults           0   0
/dev/fd0    /mnt/floppy  vfat     defaults           0   0
/dev/cdrom  /cdrom       iso9660  user, ro, noauto   0   0
</pre>
					</dd>
					<dd>Den første kolonnen viser hvilken "enhet" (device fil) det er snakk om. Neste kolonne viser hvilken katalog denne enheten skal mountes til. Det neste er hvilket filsystem som denne enheten har, i vårt tilfelle er det standard cdrom-format (iso9660). Så kommer kolonnen som viser diverse spesifikasjoner som kan brukes under mounting; "user" vil si at andre brukere enn root kan mounte denne enheten, den er kun lesbar "ro", og den skal ikke mountes under oppstart "noauto".</dd>
					<dd>De to siste kolonnen er av mindre interesse, men det kan være greit å vite hva de står for: Den nest siste kolonnen, kalt "dump flag", sier om denne enheten skal det bli tatt backup av. Den siste kolonnen, "check sequence", avgjør hvordan systemet skal sjekke filsystemene under oppstart. Root disken skal alltid ha verdi 1, andre disker skal ha verdi 2. Swap og andre disker skal ha verdi 0.</dd>

					<dd>På denne måten trenger vi bare å skrive:</dd>
					<dd><code>[bruker@pc ~]$ mount /cdrom</code></dd>

					<dt>mkfs -t < filsystem > < enhet ></dt>
					<dd>Brukes til å formatere en harddisk eller diskett. Eks. på formatering av diskett (1.4"):</dd>
					<dd><code>[bruker@pc ~]$ mkfs -t ext2 /dev/fd0 1440</code></dd>

					<dt>fsck < disk ></dt>
					<dd>Sjekker om en disk inneholder feil. Kan minne veldig om chkdsk eller scandisk i DOS. NB! Ikke kjør denne kommandoen på en disk som allerede er mountet! Hvis du trenger å sjekke en disk som mountes under oppstart (root "/" f.eks.), bør du startet opp Linux fra en oppstartdiskett og kjøre fsck fra den.</dd>
					<dd><code>[bruker@pc ~]$ fsck /dev/hdb1</code></dd>

					<dt>ps</dt>
					<dd>Viser en liste over alle prosesser som kjører. "ps ax | less" gir den komplette listen over prosesser som kjøres. For å finne ett spesifikt programs PID kan det f.eks. skrives: "ps -ax | grep netscape". Her er ett lite utdrag fra en "ps -ax" kommando:</dd>
					<dd>
<pre class="fss">
[bruker@pc ~]$ ps -ax
PID TTY   STAT   TIME   COMMAND 
 609 ?     S     0:00   /usr/X11R6/bin/xdm -nodaemon
 622 ?     S     0:44   /etc/X11/X -auth /usr/X11R6/lib/X11/xdm/authdir/authf
 873 ?     S     0:00   -:0                                                 
8099 ?     S     0:08   /local/ssh/sbin/sshd
8123 ?     S     0:00   /local/X11R6/bin/xdm -config /local/X11R6/lib/X11/xdm
8201 ?     S<    0:16   /local/sbin/xntpd -p /etc/xntpd.pid
9237 ?     S     0:00   su
9241 ?     S     0:00   bash 
9439 ?     S     0:00   mysqld
9440 ?     S     0:02   mysqld
9441 ?     S     0:00   mysqld
9497 ?     S     0:00   /opt/apache/bin/httpd
9498 ?     S     0:00   /opt/apache/bin/httpd
9499 ?     S     0:00   /opt/apache/bin/httpd
</pre>
					</dd>
					<dd>
						<strong>Eksempler</strong>
						<dl class="clear">
							<div class="fl w5">
								<dt><code>ps v -u dittbrukernavn</code></dt>
								<dd>Skriver ut info. for alle prosessene som tilhører det angitte brukernavnet, i "virtual memory format" (hvor mye virtuelt minne prosessen har tilgjengelig og faktisk bruker).</dd>

								<dt><code>ps -ef</code></dt>
								<dd>Viser alle prosesser på systemet (opsjonen -e), i "full format" (opsjonen -f).</dd>
							</div>
							<div class="fl w5">
								<dt><code>ps -eo euser,ruser,suser,fuser,f,comm,label</code></dt>
								<dd>Viser alle prosesser på systemet (opsjonen -e), bruker opsjonen -o til å angi eksplisitt hvilken informasjon (kolonner med utskrift) vi ønsker å se for prosessene.</dd>

								<dt><code>ps aux | cut -c1-8 | sort | uniq -c | sort -nrb | head -10</code></dt>
								<dd>Viser, i sortert rekkefølge, de 10 brukerne med flest prosesser på systemet.</dd>
							</div>
							<dt><code>ps -ely</code></dt>
							<dd>Viser alle prosesser på systemet (opsjonen -e), i "long format" (opsjonen -l), uten F-feltet (process flag), med angivelse av hvor mye minne (RSS-feltet) prosessen bruker i stedet for minneadressen (ADDR-feltet) til prosessen (opsjonen -y).</dd>
						</dl>
					</dd>

				</dl>
			</div>
		</section>
		<section class="w4">
			<div class="row">
				<dl>
					<dt>nice</dt>
					<dd>Lar deg kjøre prosesser som tar hensyn til systemressuser.</dd>
					<dd><code>nice -15 ./mittprogram &</code></dd>
					<dd>Starter mittprogram som en bakgrunnsprosess, med redusert prioritet (nice-verdi 15).</dd>

					<dt>kill < pid ></dt>
					<dd>Avslutter programmer. For å kille ett program, må vi vite hva slags PID det har. "kill -9 < pid >"</dd>

					<dt>shutdown</dt>
					<dd>Ett vanlig Linux-system skal aldrig bare slåes rett av. Den må "kjøres ned". Dette gjøres ved bruk av kommandoen shutdown. For å reboot en Linux maskin brukes kommandoen:</dd>
					<dd>
						<dl>
							<dt>For å slå av en Linux maskin brukes kommandoen:</dt>
							<dd><code>[bruker@pc ~]$ shutdown -r now</code></dd>

							<dt>På en vanlig flerbruker server kan vi gi brukerene litt tid til å logge av maskinen:</dt>
							<dd><code>[bruker@pc ~]$ shutdown -h +60</code></dd>
						</dl>
					</dd>
					<dd>På større systemer med mange brukere er det vanlig at melding om nedkjøring av en server gis flere dager i forveien. Du kan også legge melding om det i filen /etc/motd, på denne måten vil alle som logger seg inn få beskjed. Denne kommandoen har flere bruksmåter, se man sidene for mer informasjon.</dd>

					<dt>fdisk < enhet ></dt>
					<dd>Brukes til å partitionere om harddisk. Se "man fdisk" for mer om bruken av fdisk.</dd>


					<dt>pwconv</dt>
					<dd>Hvis shadow ikke er aktivert, er passordet (kryptert), lesbart for alle. Dette er som oftest ingen god idé. Ved å skjule passordet i den restriktige filen shadow, har vi sikret oss mot det. For å deaktivere shadow, bruker vi pwunconv.</dd>
				</dl>
				<h2>grep</h2>
<pre class="fss">
Usage: grep [OPTION]... PATTERN [FILE]...
Search for PATTERN in each FILE.
Example: grep -i 'hello world' menu.h main.c

Pattern selection and interpretation:
  -E, --extended-regexp     PATTERN is an extended regular expression
  -F, --fixed-strings       PATTERN is a set of newline-separated strings
  -G, --basic-regexp        PATTERN is a basic regular expression (default)
  -P, --perl-regexp         PATTERN is a Perl regular expression
  -e, --regexp=PATTERN      use PATTERN for matching
  -f, --file=FILE           obtain PATTERN from FILE
  -i, --ignore-case         ignore case distinctions
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -z, --null-data           a data line ends in 0 byte, not newline
Miscellaneous:
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
  -V, --version             display version information and exit
      --help                display this help text and exit
Output control:
  -m, --max-count=NUM       stop after NUM selected lines
  -b, --byte-offset         print the byte offset with output lines
  -n, --line-number         print line number with output lines
      --line-buffered       flush output on every line
  -H, --with-filename       print file name with output lines
  -h, --no-filename         suppress the file name prefix on output
      --label=LABEL         use LABEL as the standard input file name prefix
  -o, --only-matching       show only the part of a line matching PATTERN
  -q, --quiet, --silent     suppress all normal output
      --binary-files=TYPE   assume that binary files are TYPE;
                            TYPE is 'binary', 'text', or 'without-match'
  -a, --text                equivalent to --binary-files=text
  -I                        equivalent to --binary-files=without-match
  -d, --directories=ACTION  how to handle directories;
                            ACTION is 'read', 'recurse', or 'skip'
  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;
                            ACTION is 'read' or 'skip'
  -r, --recursive           like --directories=recurse
  -R, --dereference-recursive likewise, but follow all symlinks
      --include=FILE_PATTERN  search only files that match FILE_PATTERN
      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN
      --exclude-from=FILE     skip files matching any file pattern from FILE
      --exclude-dir=PATTERN   directories that match PATTERN will be skipped.
  -L, --files-without-match  print only names of FILEs with no selected lines
  -l, --files-with-matches  print only names of FILEs with selected lines
  -c, --count               print only a count of selected lines per FILE
  -T, --initial-tab         make tabs line up (if needed)
  -Z, --null                print 0 byte after FILE name
</pre>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section class="w4">
			<div class="row">
				<h2>sed</h2>
<pre class="fss">
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...

  -n, --quiet, --silent
                 suppress automatic printing of pattern space
  -e script, --expression=script
                 add the script to the commands to be executed
  -f script-file, --file=script-file
                 add the contents of script-file to the commands to be executed
  --follow-symlinks
                 follow symlinks when processing in place
  -i[SUFFIX], --in-place[=SUFFIX]
                 edit files in place (makes backup if SUFFIX supplied)
  -l N, --line-length=N
                 specify the desired line-wrap length for the `l' command
  --posix
                 disable all GNU extensions.
  -E, -r, --regexp-extended
                 use extended regular expressions in the script (for
                 portability use POSIX -E).
  -s, --separate
                 consider files as separate rather than as a single, continuous
                 long stream.
      --sandbox
                 operate in sandbox mode.
  -u, --unbuffered
                 load minimal amounts of data from the input files andflush the
                 output buffers more often
  -z, --null-data
                 separate lines by NUL characters
      --help     display this help and exit
      --version  output version information and exit
</pre>
				<h2>cut</h2>
<pre class="fss">
Usage: cut OPTION... [FILE]...
Print selected parts of lines from each FILE to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --bytes=LIST        select only these bytes
  -c, --characters=LIST   select only these characters
  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter
  -f, --fields=LIST       select only these fields; 
                          also print any line that contains no delimiter character,
                          unless the -s is specified
  -n                      (ignored)
      --complement        complement the set of selected bytes, characters or fields
  -s, --only-delimited    do not print lines not containing delimiters
      --output-delimiter=STRING  use STRING as the output delimiter the default is to
                                 use the input delimiter
  -z, --zero-terminated    line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit
</pre>
			</div>
		</section>
		<section class="w6">
			<div class="row">
				<h2>sort</h2>
<pre class="fss">
Usage: sort [OPTION]... [FILE]...
  or:  sort [OPTION]... --files0-from=F
Write sorted concatenation of all FILE(s) to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
Ordering options:

  -b, --ignore-leading-blanks  ignore leading blanks
  -d, --dictionary-order      consider only blanks and alphanumeric characters
  -f, --ignore-case           fold lower case to upper case characters
  -g, --general-numeric-sort  compare according to general numerical value
  -i, --ignore-nonprinting    consider only printable characters
  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'
  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)
  -n, --numeric-sort          compare according to string numerical value
  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)
      --random-source=FILE    get random bytes from FILE
  -r, --reverse               reverse the result of comparisons
      --sort=WORD             sort according to WORD:
                                general-numeric -g, human-numeric -h, month -M,
                                numeric -n, random -R, version -V
  -V, --version-sort          natural sort of (version) numbers within text

Other options:
      --batch-size=NMERGE   merge at most NMERGE inputs at once; for more use temp files
  -c, --check, --check=diagnose-first  check for sorted input; do not sort
  -C, --check=quiet, --check=silent  like -c, but do not report first bad line
      --compress-program=PROG  compress temporaries with PROG; decompress them with PROG -d
      --debug               annotate the part of the line used to sort, and warn about questionable usage to stderr
      --files0-from=F       read input from the files specified by NUL-terminated names in file F;
                            If F is - then read names from standard input
  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type
  -m, --merge               merge already sorted files; do not sort
  -o, --output=FILE         write result to FILE instead of standard output
  -s, --stable              stabilize sort by disabling last-resort comparison
  -S, --buffer-size=SIZE    use SIZE for main memory buffer
  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition
  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or /tmp; multiple options specify multiple directories
      --parallel=N          change the number of sorts run concurrently to N
  -u, --unique              with -c, check for strict ordering; without -c, output only the first of an equal run
  -z, --zero-terminated     line delimiter is NUL, not newline
      --help     display this help and exit
      --version  output version information and exit
</pre>
				<h4>Eksempler</h4>
				<dl>
					<dt><code>sort foo -o foo</code></dt>
					<dd>Sorterer filen foo, overskriver filen med "seg selv".</dd>

					<dt><code>sort < foo | tee foo.sort | lpr</code></dt>
					<dd>Sorterer filen foo, skriver sorterte linjer til filen foo.sort og til printer (se manualsidene for tee og lpr).</dd>

					<dt><code>cat | sort >> foo.bar</code></dt>
					<dd>Sorterer standard input og legger sorterte linjer på slutten av filen foo.bar.</dd>

					<dt><code>ls -R | grep .*\.java$ | sort</code></dt>
					<dd>ls -R lister navnene på alle filer i hele katalogtreet, grep-kommandoen filtrerer ut bare linjer som slutter med .java, før linjene til slutt sender til sortering.</dd>

					<dt>Oppgaver</dt>
					<dd>Fil inneholder linjer med: <code>Registreringsnr:Bilmerke:Modell:Årsmodell:Eier:Kilometerstand:Verdi</code>. Eks på linje: <code>AA63187:Volkswagen:Karmann-Ghia:1969:Høiberg,Jan:61338:250000</code></dd>
					<dd>
						<dl>
							<dt>Sorter filen på bilenes verdi, slik at bilen med høyest verdi kommer først. Den sorterte filen skal skrives over den opprinnelige filen.</dt>
							<dd><code>sort -t: -nr -k7 -o bildata bildata</code></dd>

							<dt>Som i punkt 1., men i tillegg skal biler med lik verdi ligge sortert stigende på årsmodell.</dt>
							<dd><code>sort -t: -k7nr -k4n -o bildata bildata</code></dd>

							<dt>Sorter filen alfabetisk etter navn på eier. Sorteringen skal være riktig også hvis noen av navnene er skrevet med bare små eller bare store bokstaver.</dt>
							<dd><code>sort -i -t: -k5d bildata</code></dd>

							<dt>Skriv ut reg.nr. og verdi for de 20 bilene som har lavest verdi.</dt>
							<dd><code>cut -d: -f1,7 bildata | sort -t: -k2n | head -20</code></dd>

							<dt>Finn og skriv ut i sortert rekkefølge (sortert etter antall biler), navnet på de 10 personene som eier flest biler.</dt>
							<dd><code>cut -d: -f5 bildata | sort | uniq -c | sort -nr | head -10</code></dd>

							<dt>Lag en sortert fil med navn tilsalgs. Filen skal være sortert på verdi, og skal kun inneholde bilmerke, årsmodell, kilometerstand og verdi.</dt>
							<dd><code>cut -d: -f2,4,6,7 bildata | sort -t: -k4n > tilsalgs</code></dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section class="w4">
			<div class="row">
				<h2>tr</h2>
<pre class="fss">
Usage: tr [OPTION]... SET1 [SET2]
Translate, squeeze, and/or delete characters from standard input,
writing to standard output.

  -c, -C, --complement    use the complement of SET1
  -d, --delete            delete characters in SET1, do not translate
  -s, --squeeze-repeats   replace each sequence of a repeated character
                            that is listed in the last specified SET,
                            with a single occurrence of that character
  -t, --truncate-set1     first truncate SET1 to length of SET2
      --help     display this help and exit
      --version  output version information and exit

SETs are specified as strings of characters.  Most represent themselves.
Interpreted sequences are:

  \NNN            character with octal value NNN (1 to 3 octal digits)
  \\              backslash
  \a              audible BEL
  \b              backspace
  \f              form feed
  \n              new line
  \r              return
  \t              horizontal tab
  \v              vertical tab
  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order
  [CHAR*]         in SET2, copies of CHAR until length of SET1
  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0
  [:alnum:]       all letters and digits
  [:alpha:]       all letters
  [:blank:]       all horizontal whitespace
  [:cntrl:]       all control characters
  [:digit:]       all digits
  [:graph:]       all printable characters, not including space
  [:lower:]       all lower case letters
  [:print:]       all printable characters, including space
  [:punct:]       all punctuation characters
  [:space:]       all horizontal or vertical whitespace
  [:upper:]       all upper case letters
  [:xdigit:]      all hexadecimal digits
  [=CHAR=]        all characters which are equivalent to CHAR
</pre>

				<dl>
					<hr>
					<dt><h2>Switch case</h2></dt>
					<dd class="clear">
						<div class="fl w4">
<pre class="fss">
case $1 in
    hello)
        # $i is "hello"
        ;;
    9[1-3]) # <--- Regex
        # $i is 91, 92 or 93
        ;;
    *)
        # $i is non of the above
        ;;
esac
</pre>
						</div>
						<div class="fl w6">
							<strong>Gjør om fra timer til sec/min ved: bashfil -s/-m < timer ></strong>
<pre class="fss">
error() { exit 1; }

while getopts ":s:m:" o; do
    case "${o}" in
        s)
            tid=$((${OPTARG}*60*60))
            ;;
        m)
            tid=$((${OPTARG}*60))
            ;;
        *)
            error
            ;;
    esac
done
</pre>
						</div>
						<hr>
					</dd>

					<dt><h2>Until loop</h2></dt>
					<dd></dd>
					<dd>
						<strong>Tell fra 20 til 10</strong><br>
<pre class="fss">
i=20
until [  $i -lt 10 ]; do
	echo i $i
	((i--))
done
</pre>
					</dd>
				</dl>
			</div>
		</section>
		<section class="w6">
			<div class="row">
				<dl>
					<dt><h2>if</h2></dt>
					<dd>Brukes for å starte en if check</dd>
					<dd><code>if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else COMMANDS; ] fi</code></dd>
					<dd>
						<table class="table-code">
							<tbody>
								<tr>
									<td>[ -a FILE ]	</td>
									<td>True if FILE exists.</td>
								</tr>
								<tr>
									<td>[ -b FILE ]	</td>
									<td>True if FILE exists and is a block-special file.</td>
								</tr>
								<tr>
									<td>[ -c FILE ]	</td>
									<td>True if FILE exists and is a character-special file.</td>
								</tr>
								<tr>
									<td>[ -d FILE ]	</td>
									<td>True if FILE exists and is a directory.</td>
								</tr>
								<tr>
									<td>[ -e FILE ]	</td>
									<td>True if FILE exists.</td>
								</tr>
								<tr>
									<td>[ -f FILE ]	</td>
									<td>True if FILE exists and is a regular file.</td>
								</tr>
								<tr>
									<td>[ -g FILE ]	</td>
									<td>True if FILE exists and its SGID bit is set.</td>
								</tr>
								<tr>
									<td>[ -h FILE ]	</td>
									<td>True if FILE exists and is a symbolic link.</td>
								</tr>
								<tr>
									<td>[ -k FILE ]	</td>
									<td>True if FILE exists and its sticky bit is set.</td>
								</tr>
								<tr>
									<td>[ -p FILE ]	</td>
									<td>True if FILE exists and is a named pipe (FIFO).</td>
								</tr>
								<tr>
									<td>[ -r FILE ]	</td>
									<td>True if FILE exists and is readable.</td>
								</tr>
								<tr>
									<td>[ -s FILE ]	</td>
									<td>True if FILE exists and has a size greater than zero.</td>
								</tr>
								<tr>
									<td>[ -t FD ]	</td>
									<td>True if file descriptor FD is open and refers to a terminal.</td>
								</tr>
								<tr>
									<td>[ -u FILE ]	</td>
									<td>True if FILE exists and its SUID (set user ID) bit is set.</td>
								</tr>
								<tr>
									<td>[ -w FILE ]	</td>
									<td>True if FILE exists and is writable.</td>
								</tr>
								<tr>
									<td>[ -x FILE ]	</td>
									<td>True if FILE exists and is executable.</td>
								</tr>
								<tr>
									<td>[ -O FILE ]	</td>
									<td>True if FILE exists and is owned by the effective user ID.</td>
								</tr>
								<tr>
									<td>[ -G FILE ]	</td>
									<td>True if FILE exists and is owned by the effective group ID.</td>
								</tr>
								<tr>
									<td>[ -L FILE ]	</td>
									<td>True if FILE exists and is a symbolic link.</td>
								</tr>
								<tr>
									<td>[ -N FILE ]	</td>
									<td>True if FILE exists and has been modified since it was last read.</td>
								</tr>
								<tr>
									<td>[ -S FILE ]	</td>
									<td>True if FILE exists and is a socket.</td>
								</tr>
								<tr>
									<td>[ FILE1 -nt FILE2 ]	</td>
									<td>True if FILE1 has been changed more recently than FILE2, or if FILE1 exists and FILE2 does not.</td>
								</tr>
								<tr>
									<td>[ FILE1 -ot FILE2 ]	</td>
									<td>True if FILE1 is older than FILE2, or is FILE2 exists and FILE1 does not.</td>
								</tr>
								<tr>
									<td>[ FILE1 -ef FILE2 ]	</td>
									<td>True if FILE1 and FILE2 refer to the same device and inode numbers.</td>
								</tr>
								<tr>
									<td>[ -o OPTIONNAME ]</td>
									<td>True if shell option "OPTIONNAME" is enabled.</td>
								</tr>
								<tr>
									<td>[ -z STRING ]</td>
									<td>True of the length if "STRING" is zero.</td>
								</tr>
								<tr>
									<td>[ -n STRING ] or [ STRING ]</td>
									<td>True if the length of "STRING" is non-zero.</td>
								</tr>
								<tr>
									<td>[ STRING1 == STRING2 ]</td>
									<td>True if the strings are equal. "=" may be used instead of "==" for strict POSIX compliance.</td>
								</tr>
								<tr>
									<td>[ STRING1 != STRING2 ]</td>
									<td>True if the strings are not equal.</td>
								</tr>
								<tr>
									<td>[ STRING1 < STRING2 ]</td>
									<td>True if "STRING1" sorts before "STRING2" lexicographically in the current locale.</td>
								</tr>
								<tr>
									<td>[ STRING1 > STRING2 ]</td>
									<td>True if "STRING1" sorts after "STRING2" lexicographically in the current locale.</td>
								</tr>
								<tr>
									<td>[ ARG1 OP ARG2 ]</td>
									<td>"OP" is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if "ARG1" is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to "ARG2", respectively. "ARG1" and "ARG2" are integers.</td>
								</tr>
								<tr>
									<td><strong>Kombinering</strong></td>
									<td>Expressions may be combined using the following operators, listed in decreasing order of precedence (viktighet):</td>
								</tr>
								<tr>
									<td>[ ! EXPR ]	</td>
									<td>True if EXPR is false.</td>
								</tr>
								<tr>
									<td>[ ( EXPR ) ]	</td>
									<td>Returns the value of EXPR. This may be used to override the normal precedence of operators.</td>
								</tr>
								<tr>
									<td>[ EXPR1 -a EXPR2 ]	</td>
									<td>True if both EXPR1 and EXPR2 are true. && can also be used.</td>
								</tr>
								<tr>
									<td>[ EXPR1 -o EXPR2 ]	</td>
									<td>True if either EXPR1 or EXPR2 is true. || can also be used.</td>
								</tr>
								<tr>
									<td><strong>Eks</strong></td>
									<td></td>
								</tr>
							</tbody>
						</table>
					</dd>
					<dd class="clear">
						<div class="fl w5">
							<strong>Sjekk om en fil finnes</strong><br>
<pre class="fss">
#!/bin/bash
if [ -f /tmp/messages.txt ]; then
	# file exists
else
	# file does not exists
fi
</pre>
						</div>
						<div class="fl w5">
							<strong>Sjekk om en bash option er satt (set -o [OPTIONNAME])</strong><br>
<pre class="fss">
#!/bin/bash
if [ $USER == 'bob' ] || [ $USER == 'andy' ]
	# user is bob or andy
else
	# user is neither bob nor andy
fi
</pre>
						</div>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt><h2>While loop</h2></dt>
					<dd class="clear">
						<div class="fl w3">
							<strong>Echo hello 4 ganger</strong><br>
<pre class="fss">
i="0"
while [ $i -lt 4 ]; do
	echo "hello"
	((i++))
done
</pre>
<pre class="fss">
Kan også skrives uten ((i++)) inni loopen:
while [[ i++ -lt 4 ]];
</pre>
						</div>
						<div class="fl w3">
							<strong>Lag en ny fil hvert 5. min</strong><br>
<pre class="fss">
while true; do
	touch filename-'date +%s'.txt
	sleep 300
done
</pre>
						</div>
						<div class="fl w4 i3">
							<strong>while read</strong><br>
<pre class="fss">
echo '1 2 3 4 5 6' | while read a b c
do
  echo $a $b $c
done

$a blir 1
$b blir 2
$c blir 3 4 5 6
</pre>
						</div>
						<hr>
					</dd>

					<dt><h2>For in loop</h2></dt>
					<dd></dd>
					<dd class="clear">
						<div class="fl w5">
							<strong>Output alle filer & kataloger</strong><br>
<pre class="fss">
for i in $( ls -a ); do
	echo $i
done
</pre>
						</div>
						<div class="fl w5">
							<strong>Loop fra 1 til 10</strong><br>
<pre class="fss">
for i in $(seq 1 10); do
	echo $i;
done
</pre>
<pre class="fss">
Alternativt kan man skrive:
for i in {1..10}; do
</pre>
						</div>
						<hr>
					</dd>
				</dl>

				<h1>Regex</h1>
				<table>
					<thead>
						<tr>
							<th>Character</th>
							<th>Meaning</th>
							<th>Example</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>*</td>
							<td>Match <strong>zero, one or more</strong> of the previous</td>
							<td><code>Ah*</code> matches "<code>Ahhhhh</code>" or "<code>A</code>"</td>
						</tr>
						<tr>
							<td>?</td>
							<td>Match <strong>zero or one</strong> of the previous</td>
							<td><code>Ah?</code> matches "<code>Al</code>" or "<code>Ah</code>"
						</tr>
						<tr>
							<td>+</td>
							<td>Match <strong>one or more</strong> of the previous</td>
							<td><code>Ah+</code> matches "<code>Ah</code>" or "<code>Ahhh</code>" but not "<code>A</code>"</td>
						</tr>
						<tr>
							<td>\</td>
							<td>Used to <strong>escape</strong> a special character</td>
							<td><code>Hungry\?</code> matches "<code>Hungry?</code>"</td>
						</tr>
						<tr>
							<td>.</td>
							<td>Wildcard character, matches <strong>any</strong> character</td>
							<td><code>do.*</code> matches "<code>dog</code>", "<code>door</code>", "<code>dot</code>", etc.</td>
						</tr>
						<tr>
							<td>( )</td>
							<td><strong>Group</strong> characters</td>
							<td>See example for <code>|</code></td>
						</tr>
						<tr>
							<td>[ ]</td>
							<td>Matches a <strong>range</strong> of characters</td>
							<td>
								<code>[cbf]ar</code> matches "car", "bar", or "far"<br />
								<code>[0-9]+</code> matches any positive integer</br />
								<code>[a-zA-Z]</code> matches ascii letters a-z (uppercase and lower case)<br />
								<code>[^0-9]</code> matches any character not 0-9.
							</tr>
						</tr>
						<tr>
							<td>|</td>
							<td>Matche previous <strong>OR</strong> next character/group</td>
							<td><code>(Mon)|(Tues)day</code> matches "Monday" or "Tuesday"</td>
						</tr>
						<tr>
							<td>{  }</td>
							<td>Matches a specified <strong>number of occurrences</strong> of the previous</td>
							<td>
								<code>[0-9]{3}</code> matches "315" but not "31"<br />
								<code>[0-9]{2,4}</code> matches "12", "123", and "1234"<br />
								<code>[0-9]{2,}</code> matches "1234567..."
							</td>
						</tr>
						<tr>
							<td>^</td>
							<td><strong>Beginning</strong> of a string. Or within a character range <code>[]</code> negation.</td>
							<td><code>^http</code> matches strings that begin with http, such as a url.<br /><code>[^0-9]</code> matches any character not 0-9.</td>
						</tr>
						<tr>
							<td>$</td>
							<td><strong>End</strong> of a string.</td>
							<td><code>ing$</code> matches "exciting" but not "ingenious"</td>
						</tr>
					</tbody>
				</table>
				<table class="table-code">
					<thead>
						<tr>
							<th>Character Class</th>
							<th>Meaning</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>[:alpha:]</td>
							<td>Any letter, <code>[A-Za-z]</code></td>
						</tr>
						<tr>
							<td>[:upper:]</td>
							<td>Any uppercase letter, <code>[A-Z]</code></td>
						</tr>
						<tr>
							<td>[:lower:]</td>
							<td>Any lowercase letter, <code>[a-z]</code></td>
						</tr>
						<tr>
							<td>[:digit:]</td>
							<td>Any digit, <code>[0-9]</code></td>
						</tr>
						<tr>
							<td>[:alnum:]</td>
							<td>Any alphanumeric character, <code>[A-Za-z0-9]</code></td>
						</tr>
						<tr>
							<td>[:xdigit:]</td>
							<td>Any hexadecimal digit, <code>[0-9A-Fa-f]</code></td>
						</tr>
						<tr>
							<td>[:space:]</td>
							<td>A tab, new line, vertical tab, form feed, carriage return, or space</td>
						</tr>
						<tr>
							<td>[:blank:]</td>
							<td>A space or a tab.</td>
						</tr>
						<tr>
							<td>[:print:]</td>
							<td>Any printable character</td>
						</tr>
						<tr>
							<td>[:punct:]</td>
							<td>Any punctuation character: <code>! ' # S % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ / ] ^ _ { | } ~</code></td>
						</tr>
						<tr>
							<td>[:graph:]</td>
							<td>Any character defined as a printable character except those defined as part of the space character class</td>
						</tr>
						<tr>
							<td>[:word:]</td>
							<td>Continuous string of alphanumeric characters and underscores.</td>
						</tr>
						<tr>
							<td>[:ascii:]</td>
							<td>ASCII characters, in the range: 0-127</td>
						</tr>
						<tr>
							<td>[:cntrl:]</td>
							<td>Any character not part of the character classes: <code>[:upper:], [:lower:], [:alpha:], [:digit:], [:punct:], [:graph:], [:print:], [:xdigit:]</code></td>
						</tr> 
					</tbody> 
				</table>
			</div>
		</section>
		<section>
			<div class="row">
				<h1>Kode eksempler</h1>
				<dl>
					<dt>Finn de 20 ordene som forekommer færrest antall ganger i en tekstfil.</dt>
					<dd class="fss"><code>tr -sc a-zA-Z "\n" < churchill.txt | tr A-Z a-z | sort | uniq -c | sort -n | tr -s ' ' ' ' | head -20</code></dd>
					
					<dt>Finn de 20 ordene som forekommer færrest antall ganger i en tekstfil, skal også funke for ord med æøå i seg.</dt>
					<dd class="fss"><code>tr -sc a-zA-ZæøåÆØÅ "\n" < kongen_2008.txt | tr A-ZÆØÅ a-zæøå | sort | uniq -c | sort -n | tr -s ' ' ' ' | head -20</code></dd>

					<dt>Lag script som:</dt>
					<dd>Ber bruker om navnet på en tekstfil, leser et filnavn F fra tastaturet og lagrer dette i en skallvariabel.</dd>
					<dd>Ber bruker om et positivt heltall N, leser og lagrer også dette tallet.</dd>
					<dd>Skriver ut de N mest brukte ordene på filen F.</dd>
					<dd>
<pre class="fss">read -p "Filnavn: " F
read -p "Positivt heltakk: " N

tr -sc a-zA-Z "\n" < $F | tr A-Z a-z | sort | uniq -c
| sort - | tr -s ' ' ' ' | head -$N
</pre>
					</dd>
					<dd>

					<dt>Sorterer teksten (persondata.txt) slik at linjene blir liggende sortert i omvendt (avtagende) rekkefølge
					på personenes alder. Personer med samme alder skal ligge sortert i stigende rekkefølge på postnummer. Den
					sorterte utskriften fra kommandoen skal lagres på en fil med navn persondata_sortert.txt.</dt>
<pre class="fss">
29:Jan:HÃ¸iberg:Darres gate 22:0175:Oslo:69215348
62:Mette:Myhrvold:Sandakerveien 10G:0743:Oslo:99106353
29:Ottar:Fjernvalg:Gata 13:2222:Rena:22232425
39:Rick:Danko:Tinker Street 10:1121:Bearsville:20102010
...
</pre>
					</dd>
					<dd><code>sort -t : -k1nr -k5n < persondata.txt -o persondata-sortert.txt</code></dd>
					<dt>Lag en ny fil med navn telefonliste.txt. Den nye filen skal ha like mange linjer som den opprinnelige filen.
					Hver linje på den nye filen skal inneholde (i rekkefølge) en persons fornavn, etternavn og telefonnummer, med
					tegnet : (kolon) mellom hvert datafelt. En linje på filen telefonliste.txt kan se slik ut: Jan:Høiberg:69215348
					Filen telefonliste.txt skal være alfabetisk sortert på etternavnet.</dt>
					<dd><code>cut -d: -f2,3,7 persondata.txt | sort -t: -k2 -o telefonliste.txt</code></dd>

					<dt>Les persondata.txt og bare skriv ut fornavn og etternavn (med tegnet : i mellom), for alle personer som
					har et postnummer som begynner med sifrene 11, 12 eller 13. Du kan anta at et postnummer alltid inneholder
					fire siffer</dt>
					<dd><code>egrep '\&lt;1[1-3][0-9]{2}\&gt;' persondata.txt | cut -d: -f2,3</code></dd>

					<dt>Les persondata.txt og lag en ny fil med navn persondata_2.txt. Den nye filen skal inneholde samme
					informasjon som persondata.txt, med unntak av at informasjon om alle personer som har et postnummer som begynner
					med sifrene 11, 12 eller 13 ikke skal være med på filen.</dt>
					<dd><code>egrep -v '\&lt;1[1-3][0-9]{2}\&gt;' persondata.txt > persondata_2.txt</code></dd>

					<dt>Skriv ut bare de tegnene fra /dev/urandom som er "printable". Output skal splittes opp i linjer, slik at
					det er 16 tegn på hver linje som skrives ut (se man fold). Det skal skrives ut 20 linjer med output.</dt>
					<dd><code>tr -cd '[:print:]' < /dev/urandom | fold -w 16 | head -20</code></dd>

					<dt>Generer 20 tilfeldige tall. Hvert tall skal ha nøyaktig 16 sifre. Tallene skal inneholde sifrene 0-9, men
					kan ikke begynne med sifferet 0 (null). Kommandoen skal skrive ut hvert tall på en egen linje.</dt>
					<dd><code>tr -cd '[:digit:]' < /dev/urandom | fold -w 16 | egrep '^[^0][0-9]{15}' | head -n20</code></dd>

					<dt>Skriv ut antall hop, enten helt frem til en gitt server, eller frem til første ruter på veien som kjører
					en brannvegg som "kaster" data fra traceroute.</dt>
					<dd><code>traceroute xdh.no | egrep '[[:digit:]]{1,2}[[:space:]]{2}(\* \* \*)' | head -n1 | egrep -o '[[:digit:]]{1,2}</code></dd>

					<dt>lag shellscript som leser følgende data interaktivt fra bruker: en URL, et ord og et filnavn</dt>
					<dd>Marker alle forekomster i teksten av ordet som bruker har angitt, med en * (stjerne) foran og bak ordet.</dd>
					<dd>Lagre hele teksten (med det angitte ordet markert med stjerner) på en ny fil med det angitte filnavnet.</dd>
					<dd>
<pre class="fss">
#!/bin/bash

read -p "URL: " url
read -p "Ord: " word
read -p "Filnavn: " filename

wget -O $filename $url

sed -i 's/'$word'/*'$word'*/g' $filename
</pre>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt>Hva er de viktigste oppgavene til et operativsystem?</dt>
					<dd>Kommunisere med bruker og styre hardware. Fordele delte ressurser som RAM, nettverksporter, disk og printere.
					Starte og kontrollere programmer. Sikre filer og data. Tilby filsystem.</dd>

					<dt>Hva er søkestien (search path) for et skall?</dt>
					<dd>En søkesti er en liste med kataloger der skallet vil lete for å finne en kommando</dd>

					<dt>Hva er navnet på skallvariabelen der søkestien lagres i Bourne-again shell?</dt>
					<dd>Søkestien ligger i systemvariabelen PATH, som inneholder en tekststreng med katalognavn adskilt med ':' (kolon).</dd>

					<dt>Nevn en fordel og en ulempe ved å bruke et GUI (grafisk grensesnitt)</dt>
					<dd>
						<dl>
							<dt>Fordeler ved GUI:</dt>
							<dd>Gjør det enklere og mer intuitivt å bruke datamaskinen. Mange brukere er vant til GUI'er (Nintendo,
							Windows, web) og arbeider lettere med pek-og-klikk verktøy.</dd>

							<dt>Ulemper ved GUI:</dt>
							<dd>Gir et "ferdigsydd" oppsett med mindre muligheter til å "skreddersy" arbeidsomgivelsene. En GUI er et
							ekstra lag med software mellom bruker og oppgavene som skal gjøres på maskinen, noe som gjør at oppgavene utføres saktere.</dd>
						</dl>
					</dd>

					<dt>Nevn en fordel og en ulempe ved å bruke et CLI (kommandolinjen)</dt>
					<dd>
						<dl>
							<dt>Fordeler ved CLI:</dt>
							<dd>Gir bedre mulighet til å kontrollere systemet og kjøre applikasjonene slik man selv ønsker. Raskt, med
							et minimalt ekstra lag med software mellom bruker og kjernen.</dd>

							<dt>Ulemper ved CLI:</dt>
							<dd>Kryptisk syntaks. Høyere inngangsterskel for nybegynnere og GUI-brukere.</dd>
						</dl>
					</dd>

					<dt>Forklar forskjellen mellom opsjoner og argumenter til en Linux-kommando.</dt>
					<dd>Opsjoner er parametre som bestemmer hvordan kommandoen skal virke. Argumenter er parametre som angir
					hvilke data kommandoen skal arbeide med, f.eks. filnavn, tall og tekststrenger.</dd>

					<dt>Hva utføres ved eksekvering av: <code>man man > man.txt</code>?</dt>
					<dd>Manualsidene til kommandoen man (manual pages) skrives til filen <code>man.txt.</code></dd>

					<dt>Hva utføres ved eksekvering av: <code>echo a*</code>?</dt>
					<dd>Navnet på alle filer i stående katalog, hvis navn begynner med en <code>a</code>, skrives ut til standard
					utenhet. Hvis det ikke finnes noen filer med navn som begynner med en <code>a</code>, skrives strengen
					<code>a*</code> ut.</dd>
				</dl>

				<p>Kommandoen <code>read</code> kan brukes for å lese inn verdier fra tastaturet og lagre dem i en variabel.
				Merk at <code>read</code> er en kommando som er "innebygget" i Bash, på samme måte som <code>history</code>. For
				å se dokumentasjonen på <code>read</code>, kan du bruke kommandoen <code>help read | more</code>. Les
				dokumentasjonen for <code>read</code>, og finn ut hvordan den virker (hva skjer hvis du prøver med
				<code>man read</code>?). Skriv en Linux-kommando som spør bruker om fornavn og etternavn (bruk opsjonen
				<code>-p</code> til <code>read</code>), og leser navnene inn i to variable. Skriv deretter en Linux-kommando som,
				hvis f.eks. brukers navn er Per Hansen, skriver ut på skjermen "Hællæ, Per Hansen".<br>
				<code>read -p "Tast inn fornavn og etternavn: " fornavn etternavn</code><br>
				<code>echo "Hællæ, $fornavn $etternavn"</code></p>

				<hr>
				<p>Opprett en ny fil med navn <code>testprogram</code> med en teksteditor. Legg inn de to kommandoene du skrev i
				forrige oppgave på hver sin linje i denne filen. Lagre filen og gå tilbake til shellet. Gi kommandoen:
				<code>bash testprogram</code>. Hva skjer? Det startes et nytt subshell som leser og utfører de to kommandoene
				som er lagret på filen (som er et skallprogram/shellscript). Deretter terminerer subshellet og kontrollen går
				tilbake til innloggings-shellet.</p>

				<dl>
					<dt>Hvilke filtyper har vi i Linux?</dt>
					<dd>
						<ul class="nostyle inline">
							<li>Regulære filer (regular/ordinary files)</li>
							<li>Kataloger (directory files)</li>
							<li>Spesialfiler (links, devices, pipes,...)</li>
						</ul>
					</dd>

					<dt>Hva er et inode-nummer i filsystemet til Linux?</dt>
					<dd>Inoden er en datastruktur i et Unix-stil-filsystem som beskriver et filsystemobjekt som en fil eller en
					katalog. Hver inode lagrer attributter og diskblokkposisjon(er) til objektets data. Attributter for
					filsystemsobjekter kan inneholde metadata som tider for siste endring og tilgang, samt eier- og tillatelsesdata.
					Kataloger er lister over navn som er tilordnet inoder. En katalog inneholder en oppføring for seg selv, sin
					forelder og hver av sine barn.</dd>

					<dt>Hva inneholder <em>egentlig</em> en katalogfil?</dt>
					<dd>En katalogfil inneholder en liste med ett element for hver fil (inkludert katalogfiler) i katalogen. Et
					element i en katalogfil kalles for en <em>hard link</em> og består av filens inode-nummer og filnavn.</dd>

					<dt>Hvordan kan vi skille en ordinær fil fra en katalogfil ved hjelp av kommandoen <code>ls</code>?</dt>
					<dd>Bruk <code>ls -l</code>, første tegn på linjen for hver fil angir da filtype, <code>d</code> for
					katalogfil, <code>-</code> for ordinær fil. Evt. kan <code>ls -F</code> brukes, da angis filtypene med et
					spesialtegn (og fargekoding i noen versjoner av <code>ls</code>) etter filnavnene.</dd>

					<dt>Skriv en Linux-kommando som skriver ut innholdet av alle filer i stående katalog som har et filnavn som
					slutter med <code>.txt</code>.</dt>
					<dd><code>cat *.txt</code></dd>

				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>(Symbolic links) For å se i praksis hvordan lenker virker, gjør følgende:</dt>
					<dd>
						<dl>
							<dt>Opprett en fil med navn abcd.txt som inneholder et par linjer med tekst.</dt>
							<dd><code>nano/emacs/vim abcd.txt</code></dd>

							<dt>Bruk <code>ln</code> til å lage en hard lenke med navn <code>abcd_hard.txt</code> og en symbolsk lenke
							med navn <code>abcd_soft.txt</code>, som begge peker til filen <code>abcd.txt</code>.</dt>
							<dd><code>ln abcd.txt abcd_hard.txt</code><span class="i5"><code>ln -s abcd.txt abcd_soft.txt</code></span></dd>

							<dt>Skriv ut innholdet av tekstfilen og av begge lenkene med <code>cat</code>, for å verifisere at de
							refererer til samme datafil.</dt>
							<dd><code>cat abcd.txt</code>, <code>cat abcd_soft.txt</code>, <code>cat abcd_hard.txt</code>, </dd>

							<dt>Skriv ut inodenummerne til tekstfilen og til de to lenkene, med <code>ls -i</code>. Hva ser du?</dt>
							<dd>Hvis det er flere hard-links til samme fil, vil de ha samme inode-nummer. Filen lagres bare ett sted,
							men det kan være flere katalogfiler med hard-links som peker til samme fil.</dd>

							<dt>Skriv ut informasjon om bl.a. filtype, størrelse og antall (harde) lenker for tekstfilen og de to
							lenkene, med <code>ls -l</code>. Hva ser du?</dt>
							<dd>Det to hard-linkene har samme filinformasjon, og viser at det er to hard-links til filen. Soft-linken
							er en egen fil med eget inode-nummer og størrelse lik antall bytes i den symbolske linken.</dd>

							<dt>Fjern tekstfilen <code>abcd.txt</code>. Prøv deretter å skrive ut innholdet av både den harde og den
							symbolske lenken. Hva skjer, og hvorfor?</dt>
							<dd>Den symbolske lenken virker ikke lenger, fordi filnavnet den lenker til er fjernet. Filen i seg selv
							fjernes ikke, fordi det fortsatt finnes en hard-link til den.</dd>
						</dl>
					</dd>

					<dt>Opprett en tom fil med touch. Gjør om tilgangsrettighetene til denne filen slik at det bare er du selv som har full tilgang, mens de som er medlem i gruppen din bare kan lese filen, og alle andre verken kan lese endre eller eksekvere den.</dt>
					<dd>
<pre class="fss">
touch tom-fil
chmod 740 tom-fil
</pre>
					</dd>
					<dd>Alternativt kan det brukes tre kommandoer med symbolske tilgangsrettigheter i stedet for en tre-sifret file mode:</dd>
					<code>chmod u=rwx tom-fil; chmod g=r tom-fil; chmod o= tom-fil</code>

					<dt>Forklar hva kommandoene gjør:</dt>
					<dd>
						<dl>
							<dt><code>kill -9 1212 1313 1414</code></dt>
							<dd>Sender signalet SIGKILL til tre prosesser med angitte PID-numre. Prosessene vil terminere hvis brukeren som gir kill-kommandoen er prosesseier.</dd>

							<dt><code>pkill mysqld</code></dt>
							<dd>Sender signalet SIGTERM til alle brukerens prosesser som er startet med kommandoen mysqld.</dd>

							<dt><code>killall mysqld</code></dt>
							<dd>Vil her gjøre det samme som kommandoen i forrige deloppgave. Se manualsidene for en beskrivelse av forskjellene i virkemåte for pkill og killall.</dd>

							<dt><code>ps aux --sort -rss | more</code></dt>
							<dd>Skriver ut (en "side" om gangen med more) alle prosesser på systemet, sortert etter hvor mye fysisk minne som er satt av til prosessene.</dd>
						</dl>
					</dd>

					<dt>Skriv en sammensatt Linux-kommando som, for et gitt brukernavn, skriver ut informasjon om de 5 prosessene som brukeren har på systemet som bruker mest minneressurser. Hint: Ta utgangspunkt i ps-varianten i siste deloppgave ovenfor, utvid denne og kombiner med head.</dt>
					<dd>Her er det ingen "fasit", siden det ikke er angitt hvilke data som skal skrives ut for prosessene. En mulig løsning er:</dd>
					<dd><code>ps ux -u janh --sort -rss | head -6</code></dd>

					<dt>En gammel eksamensoppgave om prosesshåndtering</dt>
					<dd>Du skal sortere linjene i en meget stor tekstfil. Sorteringen krever mye ressurser og kjøretid på Linux-systemet.</dd>
					<dd>
						<dl>
							<dt>a) Sorteringen skal helst være ferdig før du logger deg ut, men du vil gjerne kunne gjøre andre ting på maskinen mens sorteringen pågår. Du er også en snill bruker som ikke vil stjele for mye prosessorkraft fra de andre brukerne som er logget på. Skriv en Linux-kommando som løser dette problemet for deg.</dt>
							<dd><code>nice sort tekstfil &</code></dd>

							<dt>b) Du blir lei av å vente på at sorteringsjobben fra oppgave a) skal bli ferdig, og bestemmer deg for å terminere den. Hvordan vil du gjøre dette?</dt>
							<dd>Finn PID for prosessen med bruk av ps. Bruk deretter f.eks. kill -9 PID.</dd>

							<dt>c) Etter å ha stoppet sorteringsjobben, finner du ut at du vil starte den en gang til. Problemet nå er at polet stenger om 5 minutter og du må derfor straks logge deg ut. Skriv en kommando som starter sorteringen på nytt, og sikrer at den fortsetter etter utlogging. Hint: Se man nohup på f.eks. ask.hiof.no.</dt>
							<dd><code>nohup sort tekstfil &</code></dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dd>
						<dl>
							<dt>d) I punkt c) glemte du (sier vi) å sette ned prioriteten på sorteringen. Når du kommer tilbake etter en vellykket handel, får du forferdelig mye kjeft av av sys.adm. for å ha gjort systemet tregt i en hektisk periode. Sys.adm. har i tillegg terminert sorteringsjobben din før den var ferdig, og truer med å stenge deg ute fra systemet hvis noe lignende skjer igjen. Som en siste utvei, vil du nå prøve å kjøre sorteringen slik at den bare utføres når belastningen på maskinen er lav og det er mye ledig kapasitet i CPU, f.eks. om natten. Hvordan kan du få til dette? Hint: Se man batch og man at på f.eks. ask.hiof.no.</dt>
							<dd>Legg kommandolinjen med sorteringskommandoen som skal utføres på en fil med (f.eks.) navnet sort_job. Bruk deretter en av disse kommandoene:</dd>
							<dd><code>batch sort_job      (starter sortering når belastning er lav)</code></dd>
							<dd><code>at 3am sort_job     (starter sortering kl 3 om natten)</code></dd>

							<dt>e) Når du kommer tilbake neste morgen, får du beskjed om at sys.adm. tok ned maskinen kvelden før for uanmeldt "vedlikehold". Sorteringsjobben din er ennå ikke utført. I et anfall av raseri torturerer du sys.adm. inntil han gir deg rotpassordet, og logger deretter på systemet som superbruker/root. Forklar hvordan du nå enkelt kan kjøre sorteringen din hensynsløst og mye raskere enn tidligere.</dt>
							<dd>Superbruker/root kan starte programmer med negative nice-verdier, som gir raskere eksekvering. "Verste" mulighet er:</dd>
							<dd><code>nice --20 sort tekstfil</code></dd>
						</dl>
					</dd>

					<dt>Hva utføres av hver av disse Linux-kommandoene?</dt>
					<dd>
						<dl>
							<dt>a) <code>grep 'laks' < meny >> dagens</code></dt>
							<dd>Legger linjene i filen meny som inneholder strengen laks, på slutten av filen dagens.</dd>

							<dt>b) <code>grep 'laks' < meny | tee -a dagens | wc -l</code></dt>
							<dd>Programmet tee skriver standard input både til en angitt fil og til standard output. Kommandoen her legger linjene i filen meny som inneholder strengen laks på slutten av filen dagens, og skriver deretter ut antall linjer som ble lagt til.</dd>

							<dt>c) <code>ls | fgrep meny | wc -l</code></dt>
							<dd>Skriver ut antall filer i stående katalog som har et filnavn som inneholder strengen meny.</dd>

							<dt>d) <code>ls -al | egrep -v '^-'</code></dt>
							<dd>ls skriver ut "lang" filinformasjon (opsjonen -l) for alle filer i stående katalog, også "skjulte filer" som har et navn som begynner med tegnet '.' (opsjonen -a). egrep-kommandoen sørger for at bare filer som ikke er ordinære diskfiler (filtypen er noe annet enn '-') skrives ut.</dd>

							<dt>e) <code>egrep '^[.*]+$' foo</code></dt>
							<dd>Skriver ut linjer på filen foo som bare består av null eller flere forekomster av tegnene '.' (punktum) og '*' (stjerne) . '.' og '*' er ikke et spesialtegn i regulæruttykk når de forekommer mellom '[' og ']'.</dd>

							<dt>f) <code>egrep -vc '^$' foo</code></dt>
							<dd>Skriver ut antall linjer (opsjonen -c) på filen foo som ikke er tomme. "^$" angir en tom linje uten andre tegn enn en NEWLINE. Opsjonen -v betyr at grep skal skrive ut alle linjene som ikke matcher søkemønsteret.</dd>

							<dt>g) <code>ps aux | egrep "^$USER" | tr -s ' ' ' ' | cut -d' ' -f2,11- | sort -n</code></dt>
							<dd>Skriver ut PID og kommandoen som startet prosessen, for alle dine egne prosesser, sortert på PID.</dd>
						</dl>
					</dd>

					<dt>Fil inneholder linjer med: Registreringsnr:Bilmerke:Modell:Årsmodell:Eier:Kilometerstand:Verdi. Eksempel på linje: AA63187:Mitsubishi:Outlander:Høiberg,Jan:61338:210000. Skriv Linux-kommandoer (med piping og redirigering av I/O) som løser følgende oppgaver:</dt>
					<dd>
						<dl>
							<dt>a) Skriv ut en liste, sortert stigende på kilometerstand, med dataene for alle biler som eies av personer med etternavn lik Hansen.</dt>
							<dd><code>grep ':Hansen,' bildata | sort -t: -rn -k5</code></dd>

							<dt>b) Skriv ut antall biler med merke lik VW og modell lik Karmann Ghia.</dt>
							<dd><code>egrep -c '^[A-Z]{2}[0-9]{5}:VW:Karmann Ghia:' bildata</code></dd>

							<dt>c) Lag en ny fil med navn bildata-2 som inneholder det samme som filen bildata, med unntak av at alle forekomster av bilmerket Kia skal byttes ut med ordet Riskoker.</dt>
							<dd><code>sed 's/:Kia:/:Riskoker:/' bildata > bildata-2</code></dd>

							<dt>d) Lag en ny fil med navn bildata-3 som inneholder det samme som filen bildata, med unntak av at alle biler som har en verdi som er større eller lik 100000 skal markeres med tegnet * ('stjerne') på slutten av linjen.</dt>
							<dd><code>sed -r 's/:[1-9][0-9]{5,}$/&*/' bildata > bildata-3</code></dd>
						</dl>
					</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<dl>
					<dt>"Review question" 59, side 311 i læreboken-- script som sjekker om parameter er et palindrom:</dt>
					<dd>
						<dl>
							<div class="clear">
								<div class="fl w5">
									<dt>Løsning som bruker expr til strenghåndteringen</dt>
									<dd>
<pre class="fss">
# Palindrome checker, expr string handling version
[ $# -ne 1 ] && { echo "usage: $0 string"; exit 1; }
start=1
end=$(expr length $1)
while [ $start -lt $end ]
do
  a=$(expr substr $1 $start 1)
  b=$(expr substr $1 $end 1)
  if [ $a = $b ]
  then
    ((start++))
    ((end--))
  else
    echo "\"$1\" is not a palindrome"
    exit 1
  fi
done
echo "\"$1\" is a palindrome"
exit 0
</pre>
									</dd>
								</div>
								<div class="fl w5">
									<dt>Løsning som bruker Bash-syntaks til strenghåndteringen</dt>
									<dd>
<pre class="fss">
# Palindrome checker, Bash string handling version
[ $# -ne 1 ] && { echo "usage: $0 string"; exit 1; }
S=$1
start=0
end=$((${#S}-1))
while [ $start -lt $end ]
do
  if [ ${S:$start:1} = ${S:$end:1} ]
  then
    ((start++))
    ((end--))
  else
    echo "\"$1\" is not a palindrome"
    exit 1
  fi
done
echo "\"$1\" is a palindrome"
exit 0
</pre>
									</dd>
								</div>
							</div>
							<dt>One-liner :-)</dt>
							<dd>
<pre class="fss">
[ $(echo $1 | rev) = $1 ] && echo "\"$1\" er et palindrom" || echo "\"$1\" er ikke et palindrom"
</pre>
							</dd>
						</dl>
					</dd>

					<dt>Skriv en if-then-else-setning som tester om første parameter til et shellprogram er en katalog.</dt>
					<dd>
<pre class="fss">
if [ -d $1 ]
then
  echo "$1 er en katalog"
else
  echo "$1 er ikke en katalog"
fi
</pre>
					</dd>

					<dt>Skriv en if-then-else-setning som tester om første parameter til et shellprogram er en vanlig fil som kan leses og eksekveres.</dt>
					<dd>
<pre class="fss">
if [ -f $1 -a -r $1 -a -x $1 ]
then
  echo "$1 er en vanlig fil som kan leses og eksekveres."
else
  echo "$1 er ikke en vanlig fil som kan leses og eksekveres."
fi
</pre>
					</dd>
					
					<div class="clear">
						<div class="fl w4">
							<dt>Skriv en case setning som tester om første parameter til et shellprogram har en av verdiene "data", "source" eller "comments". Hvis parameteren ikke har noen av disse tre verdiene, skal det skrives ut en feilmelding.</dt>
							<dd>
<pre class="fss">
case $1 in
  data)
     echo "Verdi: data"
     ;;
  source)
     echo "Verdi: source"
     ;;   
  comments)
     echo "Verdi: comments"
     ;;
  *)
     echo "Ukjent verdi"
     ;;
esac
</pre>
							</dd>
						</div>
						<div class="fr w6 i2">
							<dt>Skriv en for løkke som leter etter linjer med ordet "Unix" i alle regulære, lesbare filer i stående katalog. Alle linjer som finnes skal lagres i en fil med navn Unix_linjer.</dt>
							<dd>
<pre class="fss">
for filnavn in *
do
  if [ -f $filnavn -a -r $filnavn ] 
  then
    grep UNIX $filnavn >> UNIX_linjer
  fi
done
</pre>
							</dd>
						</div>
					</div>

					<dt>Skriv et script med en uendelig løkke, som i hvert gjennomløp spør bruker etter et filnavn som skal fjernes, og fjerner filen hvis den finnes. Bruk break til å avslutte programmet når bruker taster inn filnavnet slutt.</dt>
					<dd>
<pre class="fss">
while [ true ]
do
  read -p "Tast inn filnavn: " filnavn
  if [ "$filnavn" = slutt ]
  then
    break
  elif [ -e "$filnavn" ]
  then
    rm "$filnavn"
    echo "$filnavn slettet"
  else
    echo "$filnavn finnes ikke"
  fi
done
</pre>
					</dd>
				</dl>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<dl>
					<dt>Skriv et shellprogram med en uendelig løkke, som i hvert gjennomløp sjekker om det finnes filer i katalogen /tmp som (antagelig) er tekstfiler. Hvis det finnes noen slike tekstfiler, skal de skrives ut til default printer før filene slettes. Programmet skal deretter vente i 15 minutter (se man sleep) før neste gjennomløp av løkken. Kommandoen file kan brukes til å finne ut om en fil (antagelig) er en tekstfil.</dt>
					<dd class="clear">
<pre class="fss fl w4">
cd /tmp
while [ true ]
do
  for filnavn in *
  do
    if file "$filnavn" | grep -q text
    then 
      lpr $filnavn
      rm  $filnavn
    fi
  done
  sleep 900
done
</pre>
						<div class="fl w6 i2">
							<strong>Skriv et skallprogram som går gjennom alle parametrene som er gitt til programmet. Hvis en parameter er en regulær fil der vi har lese- og skrivetilgang, skal alle dupliserte linjer på filen (identiske linjer som kommer rett etter hverandre) fjernes, slik at filen bare har unike påfølgende linjer. Resultatet av denne fjerningen av duplikater skal overskrive (lagres på samme filnavn som) den opprinnelige filen.</strong>
<pre class="fss">
#!/bin/bash
for file in $@
do
  if [ -f "$file" -a -r "$file" -a -w "$file" ]
  then
    uniq "$file" "${file}_without_duplicates"
    mv "${file}_without_duplicates" "$file"
  fi
done
</pre>
						</div>
					</dd>

					<dt>Skriv et shellprogram med navn omform som håndterer én opsjon (som kan utelates) og ett argument, på formen: <code>omform [-s|-m] t</code> Argumentet t er et tidsrom oppgitt i hele timer. omform skal regne om tiden enten til sekunder (opsjonen -s, som skal være default) eller til minutter (opsjonen -m). Resultatet skal skrives til stdout. Programmet skal sjekke at opsjoner og argumenter er riktige bl.a. med bruk av case, og skal gi fornuftige feilmeldinger</dt>
					<dd>
<pre class="fss">
#!/bin/bash

# Sjekker om antall parametre er riktig (1 eller 2)
if [ $# -lt 1 -o $# -gt 2 ]
then
   echo "usage: $0 [-s|-m] number"
   exit 1
fi

factor=3600

# Hvis to parametre, skal den fÃ¸rste vÃ¦re en opsjon
if [ $# -eq 2 ]
then

  # Tar vare pÃ¥ opsjonen, gjÃ¸r deretter en shift slik at argumentet
  # (timeantallet) alltid ligger i $1
  opt=$1
  shift

  # Sjekker at gitt opsjon er korrekt
  case $opt in
  -s)
     factor=3600
     ;;
  -m)
     factor=60
     ;;
   *)
     echo "$0: invalid option '$opt'"
     exit 1
     ;;
  esac
fi

# Tester om argumentet faktisk er et positivt heltall, selv om dette
# ikke kreves i oppgaven.En slik test pÃ¥ datatype kan gjÃ¸res pÃ¥ mange
# mÃ¥ter. Her sender vi verdien av argumentet til grep, som sjekker om
# det inneholder noen andre tegn enn sifre

if echo $1 | egrep -qv [0-9] 
then
  echo "usage: $0 [-s|-m] number"
  exit 1
fi
  
# Alt OK, skriver ut svaret og terminerer
echo $(( $factor * $1 )) 
exit 0
</pre>
					</dd>
				</dl>
			</div>
		</section>
		<section>
			<div class="row">
				<h3>Oppgave 1: Bruk av Linux shellkommandoer fra C-program</h3>
				<p>Dokumentasjon av C-bibliotekene på et Linux-system ligger integrert i manualsystemet som kan leses med kommandoen man.
				For f.eks. å se hvorledes C-funksjonen system virker, kan du skrive man system fra kommandolinjen i Linux. Du vil da se
				at system er en C-funksjon som ligger i stdlib og brukes for å utføre en shell-kommando på maskinen fra et C-program.
				F.eks. vil programlinjen: <code>system("ls");</code> i et C-program føre til at det skrives ut en liste over filene i
				stående katalog. Programmet må inneholde preprosessordirektivet #include &lt;stdlib.h&gt; i starten av koden. Skriv et
				C-program som bruker Linux-kommandoer til å skrive ut i rekkefølge: Nåværende dato og tid. En liste med info. om alle
				brukere som er logget på Linux-systemet.</p>
<pre class="fss">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
  system("date");
  system("who");
}
</pre>

				<h3>Oppgave 2: Enkel utskrift og innlesning av variable</h3>
				<p>a) Skriv et C-program som skriver ut fem linjer med fem stjerner på hver linje.</p>
<pre class="fss">
#include &lt;stdio.h&gt;

main()
{
  printf("*****\n");
  printf("*****\n");
  printf("*****\n");
  printf("*****\n");
  printf("*****\n");
}
</pre>

				<p>b) Skriv et C-program som deklarerer to heltallsvariable og en flyttallsvariabel, initialiserer disse variablene til å ha verdiene 10, 15 og 12.6, og deretter skriver dem ut.</p>
<pre class="fss">
#include &lt;stdio.h&gt;

main()
{
  int i=10, j=15;
  float f=12.6;

  printf("i=%d\tj=%d\tf=%.1f\n", i, j, f);
}
</pre>

				<p>Skriv et C-program som leser brukerens alder, og deretter skriver ut hvor gammel brukeren er i antall år, måneder, dager, timer, minutter og sekunder. Du kan anta at brukerens alder alltid er et helt antall år, og at alle år består av 365 dager.</p>
<pre class="fss">
#include &lt;stdio.h&gt;

main()
{
  int alder;
  printf("Hvor gammel er du (i antall Ã¥r)? ");
  scanf("%d", &alder);
  printf("Din alder i: Ã¥r=%d, mÃ¥neder=%d, dager=%d, timer=%d, minutter=%d, sekunder=%d\n",
	 alder, alder*12, alder*365, alder*365*24, alder*365*24*60, alder*365*24*60*60);
}
</pre>

				<p>Skriv et C-program som leser tre enkle tegn fra bruker, ikke adskilt med space, og deretter skriver ut alle de seks mulige ulike permutasjonene (omstokkingene) av de tre tegnene.</p>
<pre class="fss">
#include &lt;stdio.h&gt;

main()
{
  char c1, c2, c3;
  printf("? ");
  scanf("%c%c%c", &c1, &c2, &c3);
  printf("%c%c%c ", c1, c2, c3);
  printf("%c%c%c ", c1, c3, c2);
  printf("%c%c%c ", c2, c1, c3);
  printf("%c%c%c ", c2, c3, c1);
  printf("%c%c%c ", c3, c1, c2);
  printf("%c%c%c ", c3, c2, c1);
  printf("\n");
}
</pre>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<h3>Oppgave 3: Aritmetiske operatorer</h3>
				<p>C inneholder også aritmetiske tilordningsoperatorer som fungerer på samme måte som i Java: +=, -=, *=, /= og %=. Skriv et C-program som leser inn tre heltallsverdier a, b og c, og beregner og skriver ut verdien til a etter hver av de fem operasjonene:</p>
				<p><code>  a+=(b+=c)   a-=(b-=c)   a*=(b*=c)   a/=(b/=c)  a%=(b%=c)</code></p>
				<p>Før hver operasjon skal de tre variablene i utgangspunktet ha samme verdier som ved innlesning.</p>
<pre class="fss">
#include &lt;stdio.h&gt;
 	
main()	
{
  int A, a, B, b, C, c;
  printf("Warning: Certain input values may cause floating point exception\n");
  printf("a? b? c? ");
  scanf("%d %d %d", &A, &B, &C);
  a=A, b=B, c=C;
  a+=(b+=c);
  printf("a+=(b+=c): a=%d\n", a);

  a=A, b=B, c=C;
  a-=(b-=c);
  printf("a-=(b-=c): a=%d\n", a);

  a=A, b=B, c=C;
  a*=(b*=c);
  printf("a*=(b*=c): a=%d\n", a);

  a=A, b=B, c=C;
  a/=(b/=c);
  printf("a/=(b/=c): a=%d\n", a);

  a=A, b=B, c=C;
  a%=(b%=c);
  printf("a%%=(b%%=c): a=%d\n", a);
}
</pre>

				<h3>Oppgave 4: Seleksjon</h3>
				<p>a) Skriv et program som beregner en students karakter. Programmet skal lese prosentvis uttelling (et tall T, der 0≤T≤100) for tre oppgaver, beregne gjennomsnittet G av disse, og skrive ut karakter etter følgende regler:</p>
				<ul class="nostyle inline">
					<li>A: G≥95</li>
					<li>B: 80≤G&lt;95</li>
					<li>C: 60≤G&lt;80</li>
					<li>D: 40≤G&lt;60</li>
					<li>E: 20≤G&lt;40</li>
					<li>F: G&lt;20</li>
				</ul>
<pre class="fss">
#include &lt;stdio.h&gt;

main()
{
  float T_1, T_2, T_3;
  float G;
  
  printf("Skriv 3 prosentvise uttellinger, skilt med mellomrom: ");
  scanf("%f %f %f", &T_1, &T_2, &T_3);
  G = (T_1 + T_2 + T_3) / 3;
       
  if ( (G >= 95) && (G <= 100) )
    printf("A");
  else if ( (G >= 80) && (G < 95) )
    printf("B");
  else if ( (G >= 60) && (G < 80) ) 
    printf("C");
  else if ( (G >= 40) && (G < 60) ) 
    printf("D");
  else if ( (G >= 20) && (G < 40) ) 
    printf("E");
  else if ( (G < 20) && (G >= 0) )
     printf("F");
   else
     printf("Uhm...");
  printf("\n");
}
</pre>
			</div>
		</section>
		<section>
			<div class="row">
				<p>b) Skriv et C-program som beregner løsningen til andregradsligninger av formen: <code>ax2 + bx + c = 0, a ≠ 0</code></p>
				<p>Programmet skal lese inn verdiene for a, b og c og deretter beregne verdien: <code>D = b2 - 4ac</code></p>
				<p>Hvis D&lt;0 har ligningen ingen (reell) løsning, hvis D=0 har ligningen bare én løsning, og hvis D&gt;0 har ligningen to forskjellige løsninger.</p>
<pre class="fss">
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
 
main()
{
  float a, b, c, D;

  printf("a b c ? ");
  scanf("%f %f %f", &a, &b, &c);

  if (a == 0)
    printf("a mÃ¥ vÃ¦re forskjellig fra null\n");
  else
  {
    D = b*b - 4*a*c;
    if (D < 0)
      printf("Ingen lÃ¸sning\n");
    else if (D == 0)
      printf("LÃ¸sning: x=%f\n", -b/(2*a));
    else
      printf("LÃ¸sninger: x=%f og x=%f\n",
	     (-b - sqrt(D))/(2*a), 
	     (-b + sqrt(D))/(2*a)); 
  }
}
</pre>

				<h3>Oppgave 5: Iterasjon</h3>
				<p>Skriv et C-program som leser et positivt heltall n, og deretter skriver ut et mønster som f.eks. ser slik ut for n=7:</p>
				<div class="clear">
<pre class="fss fl br">
*******
******
*****
****
***
**
*
</pre>
<pre class="fss fl">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
  int n, i, j;
 
  printf("n? ");
  scanf("%d", &n);

  if (n <= 0)
    exit(1);
  
  for(i = 0; i < n; i++)
  {
    for(j = n - i; j > 0; j--)
      printf("*");
    printf("\n");
  }
}
</pre>
				</div>

				<p>d) Skriv et program som leser heltall fra bruker inntil det angis et tall som er mindre enn null.</p>
<pre class="fss">
#include &lt;stdio.h&gt;
 
int main()
{
  int n;
  do
    {
      printf("n? ");            
      scanf("%d", &n);
    } while (n > 0);
}
</pre>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>Forklar kort hvordan et operativsystem på en datamaskin med én enkel CPU (med bare én kjerne) tilsynelatende klarer å kjøre flere prosesser samtidig.</li>
							<li>Et OS deler tiden inn i små deler, typisk et hundredels sekund, og fordeler slike korte timeslices til alle prossene som ønsker å bruke CPU. Siden størrelsen på disse timeslicene er så liten, virker det som om flere prosesser kjører samtidig, selvom det til enhver tid kun er en eneste prosess som kjører. Ved hjelp av et interrupt fra en hardwaretimer sørges det for at OS systematisk kan dele ut CPU­tiden på denne måten.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Et meget CPU-intensivt C-program som brukes til værvarsling, kan i løpet av en halv time (30 minutter) regne ut værprognosen for neste dag på et Linux-system som har én enkel CPU. Programmet skal kjøres fire (4) ganger med fire forskjellige sett inputdata. De fire kjøringene av programmet startes samtidig. Omtrent hvor lang tid vil det ta før alle de fire værprognosene er ferdige? Begrunn svaret.</li>
							<li>Det vil ta omtrent to timer (4 x 30 minutter) å kjøre ferdig de fire kjøringene. Siden prosessene er CPU­intensive, vil de bruke nesten 100% av CPUen når de først kjører, og prosessene vil dermed i praksis måtte bytte på å bruke den ene CPU'en. Når det ikke er noen ventetid på data eller I/O, er det ikke noen tid å tjene inn på å kjøre prosessene samtidig med multitasking.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Programmet for værvarsling skrives om slik at det bruker fire tråder. Hver tråd regner ut en værprognose basert på hvert sitt sett med input-data. Omtrent hvor lang tid vil det ta før de fire værprognosene er ferdige, når de kjøres på samme Linux-system som ovenfor? Begrunn svaret</li>
							<li>Dette vil i praksis være nesten det samme som å kjøre fire separate prosesser samtidig som i forrige deloppgave. Det vil fortsatt ta ca to timer, fordi de fire trådene må dele på den ene CPUen som er tilgjengelig. En context switch går litt fortere mellom tråder enn mellom prosesser, men dette vil være ubetydelig sammenlignet med den tiden beregningene bruker. Beregningene vil også bruke litt mindre minne, siden trådene kjører felles kode.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Tråd-programmet for værvarsling flyttes til et annet Linux-system som har samme hardware som ovenfor, men som har fire identiske enkle CPU’er. Omtrent hvor lang tid bør det nå ta før de fire værprognosene er ferdige? Begrunn svaret.</li>
							<li>OS bør nå kjøre de fire trådene uavhengig og samtidig/parallelt på hver sin CPU. Hele beregningen vil da ta omtrent 30 minutter.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Meterologene som kjører værvarslingsprogrammet ønsker å se fortløpende hvor stor andel av CPU(ene) og primærminnet som programmet bruker. Hvordan kan de enkelt gjøre dette på et Linux-system?</li>
							<li>Ved å kjøre programmet top og følge med på kolonnene %CPU og %MEM.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Skriv Linux-kommandoer som utfører følgende:</p>
								<ol>
									<li>Sletter filen /tmp/log</li>
									<li>Gir deg som eier alle rettigheter til filen bare_min.txt , mens ingen andre brukere får noen rettigheter</li>
									<li>Skriver ut statusinformasjon bare om de prosessene på maskinen der prosessinformasjonen inneholder strengen emacs.</li>
								</ol>
							</li>
							<li>
								<ol>
									<li><code>rm /tmp/log</code></li>
									<li><code>chmod 700 bare_min.txt</code></li>
									<li><code>ps aux | grep emacs</code></li>
								</ol>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>2b) Hva utføres av denne kommandolinjen?: <code>maskin=$(hostname); os=$(uname);</code></li>
							<li>Skallvariabelen 'maskin' settes lik Linux­systemets hostname, og skallvariabelen 'os' settes lik navnet på OS'ets kjerne (vanligvis vil dette gi variabelen 'os' verdien "Linux").</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Følgende Linux-kommandoer blir utført:</p>
<pre class="fss">
echo "Kanye West" > data.txt
echo "Cashmere Cat" > data.txt
cat data.txt | grep Kanye > ny.txt
</pre>
								<p>Hva inneholder filen ny.txt etter at kommandoene er blitt kjørt? Begrunn svaret</p>
							</li>
							<li>Den andre kommandoen overskriver filen data.txt slik at den ikke lenger inneholder strengen "Kanye", og grep­kommandoen vil returnere null bytes. Filen ny.txt vil derfor være tom etter at kommandoene er blitt kjørt.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Hva blir resultatet av at følgende kommandoer blir kjørt? Begrunn svaret</p>
<pre class="fss">
mkdir top_secret
chmod 000 top_secret
cp /etc/passwd top_secret
</pre>
							</li>
							<li>Dette vil gi en feilmelding. chmod­kommandoen gjør at vi ikke har skrivetilgang til katalogen top_secret, og vi får derfor ikke lov til å kopiere filen passwd fra /etc til top_secret.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Hva er "runlevels" på et Linuxsystem?</li>
							<li>
								<div class="clear">
									<div class="fl w8">
										<table>
											<thead>
												<tr>
													<th>lvl</th>
													<th>Name</th>
													<th>Common usage</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>0</td>
													<td>Halt</td>
													<td>Shuts down the system; not used in inittab as it would immediately shut down on initialization.</td>
												</tr>
												<tr>
													<td>1</td>
													<td>Single-user mode</td>
													<td>Useful for administrative tasks including unmounting partitions and reinstalling portions of the OS; when used, only root access is available</td>
												</tr>
												<tr>
													<td>2</td>
													<td>Multi-user mode</td>
													<td>In multi-user mode, Linux allows users other than root to log in. In this case, network services are not started so that the user is limited to access via the console only.</td>
												</tr>
												<tr>
													<td>3</td>
													<td>Multi-user mode with networking</td>
													<td>Commonly used mode for servers or systems that do not require graphical interface.</td>
												</tr>
												<tr>
													<td>4</td>
													<td>Not used</td>
													<td>Forspecial/undefined purposes</td>
												</tr>
												<tr>
													<td>5</td>
													<td class="w3">Multi-user mode with networking and GUI</td>
													<td>Most common mode for a Linux workstation.</td>
												</tr>
												<tr>
													<td>6</td>
													<td>Reboot</td>
													<td>Reboots the system; not used in inittab because it would reboot repeatedly</td>
												</tr>
											</tbody>
										</table>
									</div>
									<div class="fl w2 i1">
										<p><strong>Runlevels</strong> sier hvilket modus serveren kjører i. går fra Runlevel 0­-6, hvor 3 og 5 er mest vanlig i produksjon, 3 er uten grafisk, og 5 er med grafisk. Tjenestene kan konfigurereres til å starte forskjellig i ulike runlevels.</p>
									</div>
								</div>
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</section>
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>Hvorfor er det viktig å partisjonere diskene i et Linuxsystem?</li>
							<li>For å sikre at viktige diskområder ikke går fulle og stopper tjenestene på serveren.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Hva er forskjellen på protokollene "TCP" og "UDP" i forhold til IPTABLES?</li>
							<li>TCP er tilstandsbevarende, så da kan du også teste på om det er en ny pakke, eller om det er en del av en strøm. UDP er tilstandsløs.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Forklar kort forskjellen på "Input-kjedet" og "Forward-kjedet" i IPTABLES.</li>
							<li>Du kan i Input­kjedet teste på trafikken som går inn til maskinen som IPTABLES kjører på. Dvs begrense eller åpne trafikk til bestemte porter (Alt etter policy). Forward­kjedet dekker trafikk inn og ut på det lokale nettet bak maskinen IPTABLES kjører på. Eks på et lokalt IP­nett bak en router. Skal du f.eks styre trafikken på de lokale maskinene på et lokalnett, så gjør du det i forward­kjedet.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Filen /proc/meminfo inneholder oppdatert informasjon om Linux-systemets minnebruk. Her er et eksempel på hvordan et utsnitt av denne filen kan se ut:</p>
<pre class="fss">
MemTotal:        8039276 kB
MemFree:         3906840 kB
Buffers:          410156 kB
Cached:          2312828 kB
SwapCached:            0 kB
Active:          2308000 kB
Inactive:        1403820 kB
Unevictable:          32 kB
Mlocked:              32 kB
SwapTotal:       8249340 kB
SwapFree:        8249340 kB
</pre>
								<p>Bruk verktøyene grep, tr og sed til å skrive en Linux-kommando på bare én linje, som henter verdiene for MemTotal og MemFree fra /proc/meminfo og skriver ut:</p>
<pre class="fss">
Totalt minne: 8039276 kB 
Ledig minne:  3906840 kB 
</pre>

							</li>
							<li><code>grep "MemTotal\|MemFree" /proc/meminfo | tr ­s ' ' ' ' | \ sed ­e 's/MemTotal/Totalt minne/' ­e 's/MemFree/Ledig minne/'</code></li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Hva utføres av shellprogrammet nedenfor?</p>
<pre class="fss">
#!/bin/bash
cd $1
for f in `ls *.mp3`
do
   mv $f ~/musikkarkiv/
done
</pre>
							</li>
							<li>Programmet flytter alle filer med filnavn som slutter med ".mp3", fra katalogen angitt som parameter til programmet, til katalogen "musikkarkiv" som ligger under brukers hjemmeområde.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Skriv om shellprogrammet i deloppgaven over, slik at det blir mer robust for feil i input.</li>
							<li>
								<p>Ny versjon av programmet som sjekker om antall parametre er riktig og av riktig type:</p>
<pre class="fss">
     [ $# ­ne 1 ] && { echo "usage: $0 directory"; exit 1; }
     [ ! ­d $1 ] && { echo "$0: $1 is not a directory"; exit 1; }
     cd $1
     for f in `ls *.mp3`
     do
        mv $f ~/musikkarkiv/
     done
</pre>
								<p>Man kan også i tillegg sjekke om vi har de nødvendige tilgangsrettigheter til katalogene og filene som brukes i programmet, men siden oppgaven bare angir at programmet skal være "robust for feil i input" er dette ikke nødvendig for å få full uttelling.</p>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Forklar hva mappen /etc/skel gjør, og nevn noen gode eksempler på bruk.</li>
							<li>/etc/skel brukes som mal for hjemmeområder når nye brukere opprettes. En systemansvarlig kan lage en mal for mappestruktur for alle nye brukere. Eks på bruk: lage gode alias i .bashrc fila for nye brukere. F.eks. sette standard editor til "Pico" e.l. Du kan også f.eks. lage en eksempelnettside i en htmlmappe for hver enkelt bruker.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Hvordan ville du gått frem for å opprette 1500 nye brukere i et Linuxsystem?</li>
							<li>Laget et script som sendte parametere til adduser kommandoen, f.eks. med parametre som brukernavn, passord, hjemmeområde osv.</li>
						</ul>
					</li>
				</ul>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>
								<p>Brukerne på et Linux-system er vanligvis definert i "passordfilen" /etc/passwd . Starten på denne filen kan se slik ut:</p>
<pre class="fss">
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
ftp:x:99:99:Anonymous FTP:/local/it/ftp:/bin/sync
snort:x:10004:1005:Snort IDS:/var/log/snort:/bin/false
nobody4:x:65534:65534:Nobody:/:/bin/sync
mroot:x:0:0:Tcsh Root account:/local/it:/bin/bash
studwww:x:24:24:web server daemon:/:/bin/bash
snort:x:10044:1005:Snort IDS:/var/log/snort:/bin/false
snort:x:10088:1005:Snort IDS:/var/log/snort:/bin/false
janh:x:1000:1000:Jan Høiberg:/home/janh:/bin/bash
</pre>
								<p>Feltene på en linje er skilt med tegnet ':' (kolon). Det første feltet på hver linje inneholder brukernavn, det tredje feltet inneholder numerisk brukerid (UID).</p>
								<p>Skriv et shellprogram som leser /etc/passwd og utfører følgende syv operasjoner:</p>
								<ol>
									<li>Skriver ut hvilken maskin (host) scriptet kjøres på og hvilket OS som kjøres.</li>
									<li>Gir feilmelding og avslutter hvis passordfilen ikke finnes eller ikke kan leses.</li>
									<li>Skriver ut en lang listing av passordfilens egenskaper (se eksemplet under).</li>
									<li>Skriver ut antall brukere definert i passordfilen.</li>
									<li>Skriver ut brukernavn for alle brukere som har UID lik 0 (null).</li>
									<li>Skriver ut alle brukernavn som forekommer flere ganger.</li>
									<li>Skriver ut alle UID som forekommer flere ganger.</li>
								</ol>
								<p>For filen gitt ovenfor kan programmet gi følgende utskrift:</p>
<pre class="fss">
Dette scriptet kjører på ask, operativsystemet er Linux
­rw­r­­r­­  1 root root 732 Nov 20 15:02 /etc/passwd
Antall brukere: 12
root har uid = 0
mroot har uid = 0
Brukernavn som forekommer flere ganger:
       3  snort
UID som forekommer flere ganger:
       2  0
       2  65534
</pre>
								<p>Noen hint som kan brukes til å løse oppgaven:</p>
								<ul>
									<li>Deloppgave 2b) ovenfor inneholder noen nyttige kommandoer...</li>
									<li>Operasjon nr 5 som programmet skal utføre løses enklest ved å pipe innholdet av passordfilen til en løkke som leser feltene på filen linje for linje.</li>
								</ul>
							</li>
							<li>
<pre class="fss">
passwd=/etc/passwd
# 1. Skriver ut hvilken maskin (host) scriptet kjøres på og hvilket OS som kjøres.
echo ­n "Dette scriptet kjører pa $(hostname),"
echo "operativsystemet er $(uname)"
# 2. Gir feilmelding og avslutter hvis passordfilen ikke finnes eller ikke kan leses.
if [ ! ­f $passwd ]
then
  echo "$0: Passordfilen finnes ikke"
  exit 1
fi
if [ ! ­r $passwd ]
then
  echo "$0: Passordfilen er ikke lesbar"
  exit 1
fi
# 3. Skriver ut en lang listing av passordfilens egenskaper
ls ­l $passwd
# 4. Skriver ut antall brukere definert i passordfilen.
echo "Antall brukere: $(wc ­l $passwd | cut ­f1 ­d' ')"
# 5. Skriver ut brukernavn for alle brukere som har UID lik 0
cat $passwd | tr : ' ' |
while read user x uid restenavlinjen
do
  if [ $uid ­eq 0 ]
  then
    echo "$user har uid = 0"
  fi
done
# 6. Skriver ut alle brukernavn som forekommer flere ganger
echo "Brukernavn som forekommer flere ganger:"
cat $passwd | cut ­f1 ­d: | sort | uniq ­cd
# 7. Skriver ut alle UID som forekommer flere ganger
echo "UID som forekommer flere ganger:"
cat $passwd | cut ­f3 ­d: | sort ­n | uniq ­cd
</pre>
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</section>
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>
								<p>Følgende C-funksjon er gitt:</p>
<pre class="fss">
void min_max(int A[], int n, int min, int max)
{
  /* 
   * Finner minste og største verdi i arrayen A
   * som har lengde n. Minste verdi returneres i
   * min, største verdi returneres i max.
   */
  int i;
  min = max = A[0];
  for (i = 1; i < n; i++)
  {    
    if (A[i] < min)
      min = A[i];
    else if (A[i] > max)
      max = A[i];
  }
}
</pre>
								<ul>
									<li>a) Denne funksjonen vil ikke fungere slik som beskrevet i kommentarene i koden. Hvorfor?</li>
									<li>b) Skriv en ny versjon av funksjonen min_max som fungerer korrekt.</li>
									<li>c) Skriv et hovedprogram som fyller en array med tilfeldige tall med verdier større enn 0 og mindre eller lik 100, og deretter tester om funksjonen min_max virker. Programmet skal skrive ut både innholdet av arrayen og resultatet fra min_max</li>
								</ul>
							</li>
							<li>
								<ul>
									<li>a) Parametrene min og max verdioverføres til funksjonen. Dvs. at det opprettes lokale variable som bare får verdien til parameteren som brukes. Alle endringer skjer lokalt og har ingen effekt på variablene som brukes i et kall på funksjonen. For at funksjonen skal virke som beskrevet, må adressene (pekere) til variablene som skal endres overføres i stedet for verdiene.</li>
									<li>
										<p>b)</p>
<pre class="fss">
void min_max(int A[], int n, int *min, int *max)
{
  int i;
  *min = *max = A[0];
  for (i = 1; i < n; i++)
  {    
    if (A[i] < *min)
      *min = A[i];
    else if (A[i] > *max)
      *max = A[i];
  }
}
</pre>
									</li>									
									<li>
										<p>c)</p>
<pre class="fss">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 10
void min_max(int[], int, int *, int *);
main() 
{
  int A[N]; 
  int i, min, max; 
  for (i = 0; i < N; i++) 
    A[i] = rand() % 100 + 1; 
  for (i = 0; i < N; i++) 
    printf("A[%d] = %d\n", i, A[i]); 
  min_max(A, N, &min, &max);
  printf("min: %d, max: %d\n", min, max);
}
</pre>
									</li>									
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Hva står DocumentRoot for i Apache-sammenheng?</li>
							<li>Starten for filområdet til webserveren – der filene som skal publiseres ligger.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Du vil passordbeskytte et webområde kalt hemmelig (mappen hemmelig ligger i DocumentRoot). Hvordan kan du gjøre dette med Apache-konfigurering?</li>
							<li>
								<p>Kan settes opp i både en &lt;Directory&gt; seksjon i <code>httpd.conf</code> (angi katalogen som skal være passordbelagt i directory konfig), eller som en <code>.htaccess</code> fil.. Skal du bruke det siste, må <code>AllowOverride AuthConfig</code> være satt i <code>httpd.conf</code>.</p>
								<p>Først setter du opp passordfila: <code>htpasswd ­c /var/www/passord torepeng.</code></p>
								<p>Skriv deretter passordet inn. Opprett <code>.htaccess</code> med følgende (eller legg det i <code>&lt;Directory /var/www/html/hemmelig&gt;</code>)</p>
<pre class="fss">
AuthType Basic
AuthName "Hemmelig katalog"
AuthBasicProvider file
AuthUserFile /var/www/passord
Require user torepeng
</pre>
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</section>
	</div>
	<div class="wrapper">
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>Du vil sperre et bestemt subnett ute fra en bestemt katalogstruktur på webserveren. Hvordan gjør du det?</li>
							<li>
<pre class="fss">
&lt;Directory "/var/www/private/public"&gt;
  Allow from all Deny from
  159.39.35.0/24 (angir et helt klasse C subnet)
&lt;/Directory&gt;
</pre>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Du ser følgende linje i Apache-konfigurasjonen din, hva gjør den?</p>
								<code>Redirect permanent /studentbedrift http://www.studentbedrift.no</code>
							</li>
							<li>Oppslag til den lokale url’en på webserven f.eks www.hiof.no/studentbedrift blir redirectet til den nye siden http://www.studentbedrift.no. I tillegg sier webserveren i fra at dette er en permanent redirect (server sender statuskode 301)</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Beskriv kort hva de forskjellige linjene i følgende direktiv gjør: </p>
<pre class="fss">
&lt;VirtualHost *:80&gt;
ServerAdmin webmaster@studentbedrift.no 
DocumentRoot /var/www/studentbedrift 
ServerName www.studentbedrift.no 
ErrorLog logs/studentbedrift.no ­error_log 
CustomLog logs/studentbedrift.no ­access_log common 
&lt;/VirtualHost&gt;
</pre>
							</li>
							<li>Setter opp at virtuell host skal svare på post 80, setter variabel ServerAdmin til webmaster@studentbedrift.no, setter webområdet som skal vise innhold til filstien /var/www/studentbedrift, setter at servernavnet som apache skal svare på til www.studentbedrift.no, oppretter egne logger for den virtuelle hosten til to separate filer. Dette gjør det lett å lete etter feil og analysere besøk til denne hosten.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Vi prater ofte om ”default policy” når vi snakker om iptables. Hva menes med dette? Forklar også hva ”accept” og ”drop” betyr i forhold til dette</li>
							<li>
							<dl>
								<dt>Default policy:</dt>
								<dd>Hovedregelen for konfigurasjonen. Skal alle pakker droppes eller aksepteres som standard.</dd>
								
								<dt>Accept:</dt>
								<dd>Pakker godtas i regelen</dd>
								
								<dt>Drop:</dt>
								<dd>Pakker slettes i regelen, ingen tilbakemelding gis til avsender av pakken</dd>
							</dl>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>
								<p>Hva gjør følgende to linjer i et iptables-skript? Forklar parameterne/variablene.</p>
<pre class="fss">
IPT ­A FORWARD ­p tcp ­d $INT_NET ­­dport 22 ­j ACCEPT
IPT ­t nat ­A PREROUTING ­d $EXT_IP ­p tcp ­­dport 22 ­j DNAT ­­to 192.168.1.3:22
</pre>
							</li>
							<li>
								<p>Første linje legger til en regel i iptables som sier at tcp pakker som skal inn til det interne nettet, og som skal til port 22 skal aksepteres.</p>
								<p>Andre linje legger til en regel i iptables som router tcp trafikk mot den eksterne ip og port 22 til den interne ip adressen 192.168.1.3 sin port 22.</p>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Du ønsker at alle nye brukere på ditt Linuxsystem skal få VI som standard teksteditor. Du vil også at de skal få en standard nettside med teksten ”Jeg har dessverre ikke oppdatert min nettside...” på adressen www.studentbedrift.no/~brukernavn . Hvordan vil du gjøre dette? Anta at Apache er satt opp til å tillate at brukere kan publisere html-filer i katalogen html­docs på sitt hjemmeområde.</li>
							<li>Først legger til en linje med $EDITOR=VI i .bashrc i /etc/skel. Deretter oppretter du mappa html­docs i /etc/skel. Deretter lager du en index.html fil inne i html­docs mappa med innholdet ”Jeg har dess....”</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Du skal slette en bruker manuelt fra systemet ditt. Hvilke filer trenger du å oppdatere for at all informasjon om brukeren skal bli borte?</li>
							<li>Slette linjen med brukerinfo i /etc/passwd, /etc/shadow, /etc/group, /etc/gshadow. Slette hele hjemmeområdet fra /home (om det er satt som hjemmeområde). Deretter slette mail ved å slette filen /var/spool/mail/brukernavn.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Du ønsker å lage en mailliste som heter medlemmer@studentbedrift.no. Enkelte av mottagerne har eksterne mailadresser, og noen er interne. Hvordan kan du gjøre dette når du er systemansvarlig for Linuxserveren som administrerer mailserveren studentbedrift.no (anta den kjører Sendmail som mailserver).</li>
							<li>Legge til en linje I /etc/aliases på følgende måte: Medlemmer: brukernavn1, brukernavn2, brukernavn3, ekstern@ekstern.com, ekstern2@ekstern.com.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Forklar hvordan Spamassassin jobber i forhold til Sendmail, og hvordan den sjekker ut hva som er ”spam” og hva som ikke er ”spam”.</li>
							<li>Litt forenklet: Sjekker header og body på mail etter gitte kriterier før det videresendes til lokale brukere. Beregner en score som settes for å beregne om mail er spam eller ikke. Om du setter spam grensen til for eksempel 5, vil mail med score høyere enn 5 få subject omskrevet til SPAM + subject. Du kan selvsagt legge til lokale mailadresser, og gi de minuspoeng, så du hindrer at mail fra direktør med tittel ”Viagratilbud” blir merket som spam.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Du administrerer webserveren til din bedrift, og ser i loggene at mange fremdeles etterspør mappen /bilder_2014 (som ble slettet i 2015). Du ønsker i stedet at de skal nå mappen /bilder_2016 . Hvordan gjør du dette, og hva slags statuskode ønsker du at apache skal svare med når brukerne forsøker å slå opp mappa /bilder_2014 ?</li>
							<li>
								<code>Redirect permanent /bilder_2014 http://www.hostname.no/bilder2016</code>
								<p>Permanent gjør at den sender rett statuskode fra APACHE også. Gjøres i httpd.conf.</p>
							</li>
						</ul>
					</li>
				</ul>
			</div>
		</section>
		<section>
			<div class="row">
				<ul class="qna">
					<li>
						<ul>
							<li>Du vil sette opp to VirtualHosts på din webserver. Det er viktig at e-post til serveradmin blir sendt til forskjellige steder, og det er viktig at hvert nettsted har forskjellige logger. Hvordan kan en slik VirtualHost konfigurasjon se ut?</li>
							<li>
								<p>Sette opp to slike i httpd.conf:</p>
<pre class="fss">
&lt;VirtualHost *:80&gt;
ServerName www.nyweb.com 
ServerAdmin webmaster@nyweb.com 
DocumentRoot /var/www/nyweb.com 
ErrorLog /var/log/httpd/nyweb.com/error_log 
CustomLog /var/log/httpd/nyweb.com/access_log custom 
&lt;/VirtualHost&gt;

&lt;VirtualHost *:80&gt;
ServerName www.nyweb2.com 
ServerAdmin webmaster@nyweb2.com 
DocumentRoot /var/www/nyweb2.com 
ErrorLog /var/log/httpd/nyweb2.com/error_log 
CustomLog /var/log/httpd/nyweb2.com/access_log custom 
&lt;/VirtualHost&gt;
</pre>
								<p>Legg merke til at det er nyweb2 som er satt som navn på den andre virtuelle hosten.</p>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Serveren går veldig tregt, og du mistenker at det er noen som prøver å "bryte seg inn" på din webserver. Hvordan kan du sjekke dette litt nærmere?</li>
							<li>Gå igjennom logger (/var/log/apache2 eller /var/log/httpd) til apache og se etter mistenkelige kode kjørt mot webserver. Sjekk load på maskinen.</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Forklar forskjellene på : 1. MUA (Mail User Agent) 2. MTA (Mail Transfer Agent) 3. MDA (Mail Delivery Agent)</li>
							<li>
								<ol>
									<li><strong>MUA</strong> (Mail User Agent) – Eks Thunderbird, Outlook Express, KMail osv.. dvs en e-postleser</li>
									<li><strong>MTA</strong> (Mail Transfer Agent) – Dvs den tjenesten som overtar etter e-post klieneten, og tar seg av selve sendingen av e-posten. Eks på en MTA er Sendmail, Postfix.</li>
									<li><strong>MDA</strong> (Mail Delivery Agent) – Det er den tjenesten som leverer mailen til den enkeltes mailbox (etter å ha gått igjennom en MTA som Sendmail). Eksempel på MDA er Procmail.</li>
								</ol>
							</li>
						</ul>
					</li>
					<li>
						<ul>
							<li>Hva er sendmail?</li>
							<li class="i2">
								<p>Utviklet seg over tid – skrevet av den legendariske Eric Allman. I følge wikipedia den mest brukte MTA.</p>
								<p>I praksis tar sendmail i mot mailen som f.eks. du og jeg sender fra Thunderbird(MUA), og deler den i to deler i katalogen “/var/spool/mqueue”. Sendmail genererer selv en random tekststreng og setter det som navn på fila. Selve innholdet (bodyen) får filendelsen “.df “(datafile), og headeren får filendelsen “.qf ” (queue file). Når mailen blir sendt, vil filene forsvinne fra mailkøen. Dvs – ligger det filer i /var/spool/mailqueue” – ligger det mail som venter på å bli sendt. Når mail blir mottatt av sendmail (fra en annen MTA), legger den mail til (“adder”) i fila /var/spool/mail/brukernavn. Alle brukere har sin egen fil her, som de har tilgang til. Denne fila er det samme som “inbox” i imapfolderen din. Bruker formatet “mbox“.</p>
								<p>Du kan tune forskjellige elementer i Sendmail. Default innstillinger kan endres i “sendmail.mc“. “sendmail.cf” skal IKKE røres. Etter at du har gjort endringer i “sendmail.mc”, restarterter du sendmail på vanlig måte (eks: “/etc/init.d/sendmail restart“) Etter at denne kommandoen er kjørt, bli “sendmail.cf” overskrevet og oppdatert med de tilpasningene du gjorde i “sendmail.mc”. Tips – Ta backup OFTE, og ikke klå for mye hvis du skal få sendmail til å virke. Mange nettleverandører (min ISP tele2.se gjør dette) stenger utgående port 25, slik at ikke alle mulige internettbrukere kan sette opp forskjellige utgaver av MTA’er som går bananas (og brukes til å spamme deg og meg). Derfor må jeg konfigurere min lokale sendmail hjemme til å benytte smtp.tele2.se som min MTA i Sendmail. Eksempler på å bruke din nettleverandør til å sende mail: <code>define(`SMART_HOST’, `smtp.tele2.se’)</code></p>
								<p>Vil du at sendmail skal kunne ta i mot mail også, er det viktig at du forteller sendmail dette. Default er sendmail konfigurert med at den kun tar i mot mail innen for sitt eget system. Fjerner du referansen til 127.0.0.1, åpner du opp for at den skal ta i mot inkonmende mail. Eksempel: <code>DAEMON_OPTIONS(`Port=smtp, Name=MTA’)dnl</code>. Sendmail kan også konfigureres slik at den sjekker om avsenderdomenet eksisterer (og at den ikke er SPAM/annet).</p>
							</li>
						</ul>
					</li>
				</ul>

				<dl>
					<dt>Working directory</dt>
					<dd>Den filkatalogen bruker står i, eller programmet/prosessen er i</dd>

					<dt>Standard innenhet og standard utenhet</dt>
					<dd><strong>stdin</strong>: Default kilde (fil) som data leses fra. Stdin er i utgangspunktet tastaturet, eller
					egentlig den vicefilen som representerer tastaturet.</dd>
					<dd><strong>stdout</strong>: Default medium (fil) som data skrives til. Stdout er i utgangspunktet skjermen.</dd>

					<dt>Filterprogram</dt>
					<dd>Program som leser tekstlige data linje for linje fra stdin, og skriver tekstlig output linjevis til stdout.</dd>

					<dt>Redirigering av I/O.</dt>
					<dd>Tegnene '<' og '>' brukes til å redefinere hhv. stdin og stdout til å være en fil i stedet for skjermen.
					'>>' (append) gjør at utskrift til stdout legges til på slutten av en eksisterende fil.</dd>

					<dt>Piping (eller "rørlegging")</dt>
					<dd>Brukes for interprosesskommunikasjon mellom to filterprogrammer. angis med tegnet '|' mellom navnene på
					programmene. Gjør at stdout fra et filter leses som stdin fra neste filter.</dd>
				</dl>
			</div>
		</section>
	</div>
</body>
</html>